ARM GAS  /tmp/cc7UAIOT.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 2
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32f1xx_it.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.NMI_Handler,"ax",%progbits
  16              		.align	1
  17              		.p2align 2,,3
  18              		.global	NMI_Handler
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	NMI_Handler:
  25              	.LFB66:
  26              		.file 1 "Src/stm32f1xx_it.c"
   1:Src/stm32f1xx_it.c **** /**
   2:Src/stm32f1xx_it.c ****   ******************************************************************************
   3:Src/stm32f1xx_it.c ****   * @file    stm32f1xx_it.c
   4:Src/stm32f1xx_it.c ****   * @brief   Interrupt Service Routines.
   5:Src/stm32f1xx_it.c ****   ******************************************************************************
   6:Src/stm32f1xx_it.c ****   *
   7:Src/stm32f1xx_it.c ****   * COPYRIGHT(c) 2018 STMicroelectronics
   8:Src/stm32f1xx_it.c ****   *
   9:Src/stm32f1xx_it.c ****   * Redistribution and use in source and binary forms, with or without modification,
  10:Src/stm32f1xx_it.c ****   * are permitted provided that the following conditions are met:
  11:Src/stm32f1xx_it.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  12:Src/stm32f1xx_it.c ****   *      this list of conditions and the following disclaimer.
  13:Src/stm32f1xx_it.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  14:Src/stm32f1xx_it.c ****   *      this list of conditions and the following disclaimer in the documentation
  15:Src/stm32f1xx_it.c ****   *      and/or other materials provided with the distribution.
  16:Src/stm32f1xx_it.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  17:Src/stm32f1xx_it.c ****   *      may be used to endorse or promote products derived from this software
  18:Src/stm32f1xx_it.c ****   *      without specific prior written permission.
  19:Src/stm32f1xx_it.c ****   *
  20:Src/stm32f1xx_it.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:Src/stm32f1xx_it.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:Src/stm32f1xx_it.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  23:Src/stm32f1xx_it.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  24:Src/stm32f1xx_it.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  25:Src/stm32f1xx_it.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  26:Src/stm32f1xx_it.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  27:Src/stm32f1xx_it.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  28:Src/stm32f1xx_it.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29:Src/stm32f1xx_it.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30:Src/stm32f1xx_it.c ****   *
  31:Src/stm32f1xx_it.c ****   ******************************************************************************
  32:Src/stm32f1xx_it.c ****   */
ARM GAS  /tmp/cc7UAIOT.s 			page 2


  33:Src/stm32f1xx_it.c **** /* Includes ------------------------------------------------------------------*/
  34:Src/stm32f1xx_it.c **** #include "stm32f1xx_hal.h"
  35:Src/stm32f1xx_it.c **** #include "stm32f1xx.h"
  36:Src/stm32f1xx_it.c **** #include "stm32f1xx_it.h"
  37:Src/stm32f1xx_it.c **** 
  38:Src/stm32f1xx_it.c **** /* USER CODE BEGIN 0 */
  39:Src/stm32f1xx_it.c **** 
  40:Src/stm32f1xx_it.c **** /* USER CODE END 0 */
  41:Src/stm32f1xx_it.c **** 
  42:Src/stm32f1xx_it.c **** /* External variables --------------------------------------------------------*/
  43:Src/stm32f1xx_it.c **** extern SPI_HandleTypeDef hspi2;
  44:Src/stm32f1xx_it.c **** 
  45:Src/stm32f1xx_it.c **** /******************************************************************************/
  46:Src/stm32f1xx_it.c **** /*            Cortex-M3 Processor Interruption and Exception Handlers         */ 
  47:Src/stm32f1xx_it.c **** /******************************************************************************/
  48:Src/stm32f1xx_it.c **** 
  49:Src/stm32f1xx_it.c **** /**
  50:Src/stm32f1xx_it.c **** * @brief This function handles Non maskable interrupt.
  51:Src/stm32f1xx_it.c **** */
  52:Src/stm32f1xx_it.c **** void NMI_Handler(void)
  53:Src/stm32f1xx_it.c **** {
  27              		.loc 1 53 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  54:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN NonMaskableInt_IRQn 0 */
  55:Src/stm32f1xx_it.c **** 
  56:Src/stm32f1xx_it.c ****   /* USER CODE END NonMaskableInt_IRQn 0 */
  57:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  58:Src/stm32f1xx_it.c **** 
  59:Src/stm32f1xx_it.c ****   /* USER CODE END NonMaskableInt_IRQn 1 */
  60:Src/stm32f1xx_it.c **** }
  32              		.loc 1 60 0
  33 0000 7047     		bx	lr
  34              		.cfi_endproc
  35              	.LFE66:
  37 0002 00BF     		.section	.text.HardFault_Handler,"ax",%progbits
  38              		.align	1
  39              		.p2align 2,,3
  40              		.global	HardFault_Handler
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu softvfp
  46              	HardFault_Handler:
  47              	.LFB67:
  61:Src/stm32f1xx_it.c **** 
  62:Src/stm32f1xx_it.c **** /**
  63:Src/stm32f1xx_it.c **** * @brief This function handles Hard fault interrupt.
  64:Src/stm32f1xx_it.c **** */
  65:Src/stm32f1xx_it.c **** void HardFault_Handler(void)
  66:Src/stm32f1xx_it.c **** {
  48              		.loc 1 66 0
  49              		.cfi_startproc
  50              		@ Volatile: function does not return.
  51              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cc7UAIOT.s 			page 3


  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53              		@ link register save eliminated.
  54              	.L4:
  55 0000 FEE7     		b	.L4
  56              		.cfi_endproc
  57              	.LFE67:
  59 0002 00BF     		.section	.text.MemManage_Handler,"ax",%progbits
  60              		.align	1
  61              		.p2align 2,,3
  62              		.global	MemManage_Handler
  63              		.syntax unified
  64              		.thumb
  65              		.thumb_func
  66              		.fpu softvfp
  68              	MemManage_Handler:
  69              	.LFB68:
  67:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN HardFault_IRQn 0 */
  68:Src/stm32f1xx_it.c **** 
  69:Src/stm32f1xx_it.c ****   /* USER CODE END HardFault_IRQn 0 */
  70:Src/stm32f1xx_it.c ****   while (1)
  71:Src/stm32f1xx_it.c ****   {
  72:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_HardFault_IRQn 0 */
  73:Src/stm32f1xx_it.c ****     /* USER CODE END W1_HardFault_IRQn 0 */
  74:Src/stm32f1xx_it.c ****   }
  75:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN HardFault_IRQn 1 */
  76:Src/stm32f1xx_it.c **** 
  77:Src/stm32f1xx_it.c ****   /* USER CODE END HardFault_IRQn 1 */
  78:Src/stm32f1xx_it.c **** }
  79:Src/stm32f1xx_it.c **** 
  80:Src/stm32f1xx_it.c **** /**
  81:Src/stm32f1xx_it.c **** * @brief This function handles Memory management fault.
  82:Src/stm32f1xx_it.c **** */
  83:Src/stm32f1xx_it.c **** void MemManage_Handler(void)
  84:Src/stm32f1xx_it.c **** {
  70              		.loc 1 84 0
  71              		.cfi_startproc
  72              		@ Volatile: function does not return.
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75              		@ link register save eliminated.
  76              	.L6:
  77 0000 FEE7     		b	.L6
  78              		.cfi_endproc
  79              	.LFE68:
  81 0002 00BF     		.section	.text.BusFault_Handler,"ax",%progbits
  82              		.align	1
  83              		.p2align 2,,3
  84              		.global	BusFault_Handler
  85              		.syntax unified
  86              		.thumb
  87              		.thumb_func
  88              		.fpu softvfp
  90              	BusFault_Handler:
  91              	.LFB69:
  85:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN MemoryManagement_IRQn 0 */
  86:Src/stm32f1xx_it.c **** 
  87:Src/stm32f1xx_it.c ****   /* USER CODE END MemoryManagement_IRQn 0 */
ARM GAS  /tmp/cc7UAIOT.s 			page 4


  88:Src/stm32f1xx_it.c ****   while (1)
  89:Src/stm32f1xx_it.c ****   {
  90:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
  91:Src/stm32f1xx_it.c ****     /* USER CODE END W1_MemoryManagement_IRQn 0 */
  92:Src/stm32f1xx_it.c ****   }
  93:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN MemoryManagement_IRQn 1 */
  94:Src/stm32f1xx_it.c **** 
  95:Src/stm32f1xx_it.c ****   /* USER CODE END MemoryManagement_IRQn 1 */
  96:Src/stm32f1xx_it.c **** }
  97:Src/stm32f1xx_it.c **** 
  98:Src/stm32f1xx_it.c **** /**
  99:Src/stm32f1xx_it.c **** * @brief This function handles Prefetch fault, memory access fault.
 100:Src/stm32f1xx_it.c **** */
 101:Src/stm32f1xx_it.c **** void BusFault_Handler(void)
 102:Src/stm32f1xx_it.c **** {
  92              		.loc 1 102 0
  93              		.cfi_startproc
  94              		@ Volatile: function does not return.
  95              		@ args = 0, pretend = 0, frame = 0
  96              		@ frame_needed = 0, uses_anonymous_args = 0
  97              		@ link register save eliminated.
  98              	.L8:
  99 0000 FEE7     		b	.L8
 100              		.cfi_endproc
 101              	.LFE69:
 103 0002 00BF     		.section	.text.UsageFault_Handler,"ax",%progbits
 104              		.align	1
 105              		.p2align 2,,3
 106              		.global	UsageFault_Handler
 107              		.syntax unified
 108              		.thumb
 109              		.thumb_func
 110              		.fpu softvfp
 112              	UsageFault_Handler:
 113              	.LFB70:
 103:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN BusFault_IRQn 0 */
 104:Src/stm32f1xx_it.c **** 
 105:Src/stm32f1xx_it.c ****   /* USER CODE END BusFault_IRQn 0 */
 106:Src/stm32f1xx_it.c ****   while (1)
 107:Src/stm32f1xx_it.c ****   {
 108:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_BusFault_IRQn 0 */
 109:Src/stm32f1xx_it.c ****     /* USER CODE END W1_BusFault_IRQn 0 */
 110:Src/stm32f1xx_it.c ****   }
 111:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN BusFault_IRQn 1 */
 112:Src/stm32f1xx_it.c **** 
 113:Src/stm32f1xx_it.c ****   /* USER CODE END BusFault_IRQn 1 */
 114:Src/stm32f1xx_it.c **** }
 115:Src/stm32f1xx_it.c **** 
 116:Src/stm32f1xx_it.c **** /**
 117:Src/stm32f1xx_it.c **** * @brief This function handles Undefined instruction or illegal state.
 118:Src/stm32f1xx_it.c **** */
 119:Src/stm32f1xx_it.c **** void UsageFault_Handler(void)
 120:Src/stm32f1xx_it.c **** {
 114              		.loc 1 120 0
 115              		.cfi_startproc
 116              		@ Volatile: function does not return.
 117              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cc7UAIOT.s 			page 5


 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120              	.L10:
 121 0000 FEE7     		b	.L10
 122              		.cfi_endproc
 123              	.LFE70:
 125 0002 00BF     		.section	.text.SVC_Handler,"ax",%progbits
 126              		.align	1
 127              		.p2align 2,,3
 128              		.global	SVC_Handler
 129              		.syntax unified
 130              		.thumb
 131              		.thumb_func
 132              		.fpu softvfp
 134              	SVC_Handler:
 135              	.LFB77:
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140 0000 7047     		bx	lr
 141              		.cfi_endproc
 142              	.LFE77:
 144 0002 00BF     		.section	.text.DebugMon_Handler,"ax",%progbits
 145              		.align	1
 146              		.p2align 2,,3
 147              		.global	DebugMon_Handler
 148              		.syntax unified
 149              		.thumb
 150              		.thumb_func
 151              		.fpu softvfp
 153              	DebugMon_Handler:
 154              	.LFB79:
 155              		.cfi_startproc
 156              		@ args = 0, pretend = 0, frame = 0
 157              		@ frame_needed = 0, uses_anonymous_args = 0
 158              		@ link register save eliminated.
 159 0000 7047     		bx	lr
 160              		.cfi_endproc
 161              	.LFE79:
 163 0002 00BF     		.section	.text.PendSV_Handler,"ax",%progbits
 164              		.align	1
 165              		.p2align 2,,3
 166              		.global	PendSV_Handler
 167              		.syntax unified
 168              		.thumb
 169              		.thumb_func
 170              		.fpu softvfp
 172              	PendSV_Handler:
 173              	.LFB81:
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178 0000 7047     		bx	lr
 179              		.cfi_endproc
 180              	.LFE81:
ARM GAS  /tmp/cc7UAIOT.s 			page 6


 182 0002 00BF     		.section	.text.SysTick_Handler,"ax",%progbits
 183              		.align	1
 184              		.p2align 2,,3
 185              		.global	SysTick_Handler
 186              		.syntax unified
 187              		.thumb
 188              		.thumb_func
 189              		.fpu softvfp
 191              	SysTick_Handler:
 192              	.LFB74:
 121:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN UsageFault_IRQn 0 */
 122:Src/stm32f1xx_it.c **** 
 123:Src/stm32f1xx_it.c ****   /* USER CODE END UsageFault_IRQn 0 */
 124:Src/stm32f1xx_it.c ****   while (1)
 125:Src/stm32f1xx_it.c ****   {
 126:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
 127:Src/stm32f1xx_it.c ****     /* USER CODE END W1_UsageFault_IRQn 0 */
 128:Src/stm32f1xx_it.c ****   }
 129:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN UsageFault_IRQn 1 */
 130:Src/stm32f1xx_it.c **** 
 131:Src/stm32f1xx_it.c ****   /* USER CODE END UsageFault_IRQn 1 */
 132:Src/stm32f1xx_it.c **** }
 133:Src/stm32f1xx_it.c **** 
 134:Src/stm32f1xx_it.c **** /**
 135:Src/stm32f1xx_it.c **** * @brief This function handles System service call via SWI instruction.
 136:Src/stm32f1xx_it.c **** */
 137:Src/stm32f1xx_it.c **** void SVC_Handler(void)
 138:Src/stm32f1xx_it.c **** {
 139:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SVCall_IRQn 0 */
 140:Src/stm32f1xx_it.c **** 
 141:Src/stm32f1xx_it.c ****   /* USER CODE END SVCall_IRQn 0 */
 142:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SVCall_IRQn 1 */
 143:Src/stm32f1xx_it.c **** 
 144:Src/stm32f1xx_it.c ****   /* USER CODE END SVCall_IRQn 1 */
 145:Src/stm32f1xx_it.c **** }
 146:Src/stm32f1xx_it.c **** 
 147:Src/stm32f1xx_it.c **** /**
 148:Src/stm32f1xx_it.c **** * @brief This function handles Debug monitor.
 149:Src/stm32f1xx_it.c **** */
 150:Src/stm32f1xx_it.c **** void DebugMon_Handler(void)
 151:Src/stm32f1xx_it.c **** {
 152:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN DebugMonitor_IRQn 0 */
 153:Src/stm32f1xx_it.c **** 
 154:Src/stm32f1xx_it.c ****   /* USER CODE END DebugMonitor_IRQn 0 */
 155:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN DebugMonitor_IRQn 1 */
 156:Src/stm32f1xx_it.c **** 
 157:Src/stm32f1xx_it.c ****   /* USER CODE END DebugMonitor_IRQn 1 */
 158:Src/stm32f1xx_it.c **** }
 159:Src/stm32f1xx_it.c **** 
 160:Src/stm32f1xx_it.c **** /**
 161:Src/stm32f1xx_it.c **** * @brief This function handles Pendable request for system service.
 162:Src/stm32f1xx_it.c **** */
 163:Src/stm32f1xx_it.c **** void PendSV_Handler(void)
 164:Src/stm32f1xx_it.c **** {
 165:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN PendSV_IRQn 0 */
 166:Src/stm32f1xx_it.c **** 
 167:Src/stm32f1xx_it.c ****   /* USER CODE END PendSV_IRQn 0 */
ARM GAS  /tmp/cc7UAIOT.s 			page 7


 168:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN PendSV_IRQn 1 */
 169:Src/stm32f1xx_it.c **** 
 170:Src/stm32f1xx_it.c ****   /* USER CODE END PendSV_IRQn 1 */
 171:Src/stm32f1xx_it.c **** }
 172:Src/stm32f1xx_it.c **** 
 173:Src/stm32f1xx_it.c **** /**
 174:Src/stm32f1xx_it.c **** * @brief This function handles System tick timer.
 175:Src/stm32f1xx_it.c **** */
 176:Src/stm32f1xx_it.c **** void SysTick_Handler(void)
 177:Src/stm32f1xx_it.c **** {
 193              		.loc 1 177 0
 194              		.cfi_startproc
 195              		@ args = 0, pretend = 0, frame = 0
 196              		@ frame_needed = 0, uses_anonymous_args = 0
 197              		.loc 1 177 0
 198 0000 08B5     		push	{r3, lr}
 199              	.LCFI0:
 200              		.cfi_def_cfa_offset 8
 201              		.cfi_offset 3, -8
 202              		.cfi_offset 14, -4
 178:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SysTick_IRQn 0 */
 179:Src/stm32f1xx_it.c **** 
 180:Src/stm32f1xx_it.c ****   /* USER CODE END SysTick_IRQn 0 */
 181:Src/stm32f1xx_it.c ****   HAL_IncTick();
 203              		.loc 1 181 0
 204 0002 FFF7FEFF 		bl	HAL_IncTick
 205              	.LVL0:
 182:Src/stm32f1xx_it.c ****   HAL_SYSTICK_IRQHandler();
 183:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SysTick_IRQn 1 */
 184:Src/stm32f1xx_it.c **** 
 185:Src/stm32f1xx_it.c ****   /* USER CODE END SysTick_IRQn 1 */
 186:Src/stm32f1xx_it.c **** }
 206              		.loc 1 186 0
 207 0006 BDE80840 		pop	{r3, lr}
 208              	.LCFI1:
 209              		.cfi_restore 14
 210              		.cfi_restore 3
 211              		.cfi_def_cfa_offset 0
 182:Src/stm32f1xx_it.c ****   HAL_SYSTICK_IRQHandler();
 212              		.loc 1 182 0
 213 000a FFF7FEBF 		b	HAL_SYSTICK_IRQHandler
 214              	.LVL1:
 215              		.cfi_endproc
 216              	.LFE74:
 218 000e 00BF     		.section	.text.SPI2_IRQHandler,"ax",%progbits
 219              		.align	1
 220              		.p2align 2,,3
 221              		.global	SPI2_IRQHandler
 222              		.syntax unified
 223              		.thumb
 224              		.thumb_func
 225              		.fpu softvfp
 227              	SPI2_IRQHandler:
 228              	.LFB75:
 187:Src/stm32f1xx_it.c **** 
 188:Src/stm32f1xx_it.c **** /******************************************************************************/
 189:Src/stm32f1xx_it.c **** /* STM32F1xx Peripheral Interrupt Handlers                                    */
ARM GAS  /tmp/cc7UAIOT.s 			page 8


 190:Src/stm32f1xx_it.c **** /* Add here the Interrupt Handlers for the used peripherals.                  */
 191:Src/stm32f1xx_it.c **** /* For the available peripheral interrupt handler names,                      */
 192:Src/stm32f1xx_it.c **** /* please refer to the startup file (startup_stm32f1xx.s).                    */
 193:Src/stm32f1xx_it.c **** /******************************************************************************/
 194:Src/stm32f1xx_it.c **** 
 195:Src/stm32f1xx_it.c **** /**
 196:Src/stm32f1xx_it.c **** * @brief This function handles SPI2 global interrupt.
 197:Src/stm32f1xx_it.c **** */
 198:Src/stm32f1xx_it.c **** static uint8_t count =0;
 199:Src/stm32f1xx_it.c **** void SPI2_IRQHandler(void)
 200:Src/stm32f1xx_it.c **** {
 229              		.loc 1 200 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              		@ link register save eliminated.
 234              	.LVL2:
 201:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SPI2_IRQn 0 */
 202:Src/stm32f1xx_it.c ****   extern uint16_t gray_data_final;
 203:Src/stm32f1xx_it.c ****   extern uint16_t gray_data_two_final;
 204:Src/stm32f1xx_it.c ****   extern uint16_t other_data_final;
 205:Src/stm32f1xx_it.c ****   uint8_t other_status_final = 0x11;
 206:Src/stm32f1xx_it.c ****   static bool start=false;
 207:Src/stm32f1xx_it.c ****   static uint8_t data_use_r = 0x00;    //Êé•ÂèóÊâßË°åËøîÂõû
 208:Src/stm32f1xx_it.c ****   static uint8_t buf[5] = {0};
 209:Src/stm32f1xx_it.c ****   static uint8_t tx_buf[2] = {0x01,0x02};
 210:Src/stm32f1xx_it.c ****   
 211:Src/stm32f1xx_it.c ****   if((SPI2->DR == 0xaa) && (start == false)){     //Êî∂Âà∞Â§¥0xaa
 235              		.loc 1 211 0
 236 0000 A04A     		ldr	r2, .L70
 237 0002 A148     		ldr	r0, .L70+4
 238 0004 D168     		ldr	r1, [r2, #12]
 200:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SPI2_IRQn 0 */
 239              		.loc 1 200 0
 240 0006 F0B4     		push	{r4, r5, r6, r7}
 241              	.LCFI2:
 242              		.cfi_def_cfa_offset 16
 243              		.cfi_offset 4, -16
 244              		.cfi_offset 5, -12
 245              		.cfi_offset 6, -8
 246              		.cfi_offset 7, -4
 247              		.loc 1 211 0
 248 0008 AA29     		cmp	r1, #170
 249 000a 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 250 000c 41D0     		beq	.L57
 251              	.L17:
 212:Src/stm32f1xx_it.c ****     start = true;
 213:Src/stm32f1xx_it.c ****     count ++;
 214:Src/stm32f1xx_it.c ****     SPI2->DR = other_status_final;                              //ÂèØÊõøÊç¢ÊàêÁ®ãÂ∫èËøêË°åÂºÄÂÖ≥Áä∂
 215:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 1)){      //Êî∂Âà∞ÊéßÂà∂‰ΩçÔºå‰ª£Ë°®Âêé‰∏§‰ΩçË¶ÅÂèëÁöÑ‰∏úË•
 252              		.loc 1 215 0
 253 000e 012B     		cmp	r3, #1
 254 0010 50D0     		beq	.L58
 255 0012 9E4B     		ldr	r3, .L70+8
 256 0014 9E4E     		ldr	r6, .L70+12
 257 0016 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 258              	.L25:
ARM GAS  /tmp/cc7UAIOT.s 			page 9


 216:Src/stm32f1xx_it.c ****     buf[0] = SPI2->DR;
 217:Src/stm32f1xx_it.c ****     SPI2->DR = other_status_final;
 218:Src/stm32f1xx_it.c ****     count ++;
 219:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 2)){      //Êî∂Âà∞È´ò8‰ΩçÔºåÂèëÈÄÅÊéßÂà∂‰Ωç
 220:Src/stm32f1xx_it.c ****     buf[1] = SPI2->DR;
 221:Src/stm32f1xx_it.c ****     SPI2->DR = buf[0];
 222:Src/stm32f1xx_it.c ****     count ++;
 223:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 3)){      //Êî∂Âà∞‰Ωé8‰ΩçÔºåÂèëÈÄÅÊï∞ÊçÆ‰Ωç
 224:Src/stm32f1xx_it.c ****     buf[2] = SPI2->DR;
 225:Src/stm32f1xx_it.c ****     SPI2->DR = tx_buf[0];
 226:Src/stm32f1xx_it.c ****     count ++;
 227:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 4)){      //ÂèëÈÄÅÊï∞ÊçÆ‰Ωç
 228:Src/stm32f1xx_it.c ****     SPI2->DR = tx_buf[1];
 229:Src/stm32f1xx_it.c ****     count ++;
 230:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 5)){      //ÂèëÈÄÅÊï∞ÊçÆÊ†°È™å
 231:Src/stm32f1xx_it.c ****     SPI2->DR = (tx_buf[0] + tx_buf[1]) & 0xff;
 232:Src/stm32f1xx_it.c ****     count ++;
 233:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 6)){      //ÂèëÈÄÅÊï∞ÊçÆ‰ΩøÁî®ÊÉÖÂÜµ
 234:Src/stm32f1xx_it.c ****     buf[3] = SPI2->DR;
 235:Src/stm32f1xx_it.c ****     SPI2->DR = data_use_r;
 236:Src/stm32f1xx_it.c ****     count ++;
 237:Src/stm32f1xx_it.c ****   }else{
 238:Src/stm32f1xx_it.c ****     count = 0;
 259              		.loc 1 238 0
 260 0018 0025     		movs	r5, #0
 261 001a 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 239:Src/stm32f1xx_it.c ****     start = false;
 262              		.loc 1 239 0
 263 001c 0570     		strb	r5, [r0]
 264 001e 2946     		mov	r1, r5
 238:Src/stm32f1xx_it.c ****     start = false;
 265              		.loc 1 238 0
 266 0020 3570     		strb	r5, [r6]
 267 0022 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 268 0024 DD78     		ldrb	r5, [r3, #3]	@ zero_extendqisi2
 269              	.L18:
 240:Src/stm32f1xx_it.c ****   }
 241:Src/stm32f1xx_it.c **** 
 242:Src/stm32f1xx_it.c ****   uint8_t temp_num = 0xaa + buf[0] +buf[1] +buf[2];
 270              		.loc 1 242 0
 271 0026 1319     		adds	r3, r2, r4
 272 0028 563B     		subs	r3, r3, #86
 273 002a 0344     		add	r3, r3, r0
 243:Src/stm32f1xx_it.c ****   
 244:Src/stm32f1xx_it.c ****   if(buf[0] == 0x21){
 274              		.loc 1 244 0
 275 002c 212A     		cmp	r2, #33
 242:Src/stm32f1xx_it.c ****   
 276              		.loc 1 242 0
 277 002e DBB2     		uxtb	r3, r3
 278              	.LVL3:
 279              		.loc 1 244 0
 280 0030 2DD0     		beq	.L59
 245:Src/stm32f1xx_it.c ****     tx_buf[0] = ((gray_data_final&0xff00)>>8);
 246:Src/stm32f1xx_it.c ****     tx_buf[1] = (gray_data_final&0x00ff);
 247:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x22){
 281              		.loc 1 247 0
ARM GAS  /tmp/cc7UAIOT.s 			page 10


 282 0032 222A     		cmp	r2, #34
 283 0034 0DD0     		beq	.L60
 248:Src/stm32f1xx_it.c ****     tx_buf[0] = ((gray_data_two_final&0xff00)>>8);
 249:Src/stm32f1xx_it.c ****     tx_buf[1] = (gray_data_two_final&0x00ff);
 250:Src/stm32f1xx_it.c ****   }else if((buf[0]&0xf0) == 0x50){
 284              		.loc 1 250 0
 285 0036 02F0F006 		and	r6, r2, #240
 286 003a 502E     		cmp	r6, #80
 287 003c 00F08980 		beq	.L61
 288              	.L27:
 251:Src/stm32f1xx_it.c ****     uint16_t steer_temp = 0x00;
 252:Src/stm32f1xx_it.c ****     switch(buf[0]){
 253:Src/stm32f1xx_it.c ****       case 0x51:
 254:Src/stm32f1xx_it.c ****         steer_temp = 0x01;
 255:Src/stm32f1xx_it.c ****         //steer_temp = TIM3->CCR4 - 1500;
 256:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 257:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 258:Src/stm32f1xx_it.c ****         break;
 259:Src/stm32f1xx_it.c ****       case 0x52:
 260:Src/stm32f1xx_it.c ****         steer_temp = 0x02;
 261:Src/stm32f1xx_it.c ****         //steer_temp = TIM3->CCR3 - 1500;
 262:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 263:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 264:Src/stm32f1xx_it.c ****         break;
 265:Src/stm32f1xx_it.c ****       case 0x53:
 266:Src/stm32f1xx_it.c ****         steer_temp = 0x03;
 267:Src/stm32f1xx_it.c ****         //steer_temp = TIM3->CCR2 - 1500;
 268:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 269:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 270:Src/stm32f1xx_it.c ****         break;
 271:Src/stm32f1xx_it.c ****       case 0x54:
 272:Src/stm32f1xx_it.c ****         steer_temp = 0x04;
 273:Src/stm32f1xx_it.c ****         //steer_temp = TIM3->CCR1 - 1500;
 274:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 275:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 276:Src/stm32f1xx_it.c ****         break;
 277:Src/stm32f1xx_it.c ****       case 0x55:
 278:Src/stm32f1xx_it.c ****         steer_temp = 0x05;
 279:Src/stm32f1xx_it.c ****         //steer_temp = TIM2->CCR4 - 1500;
 280:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 281:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 282:Src/stm32f1xx_it.c ****         break;
 283:Src/stm32f1xx_it.c ****       case 0x56:
 284:Src/stm32f1xx_it.c ****         steer_temp = 0x06;
 285:Src/stm32f1xx_it.c ****         //steer_temp = TIM2->CCR3 - 1500;
 286:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 287:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 288:Src/stm32f1xx_it.c ****         break;
 289:Src/stm32f1xx_it.c ****       case 0x57:
 290:Src/stm32f1xx_it.c ****         steer_temp = 0x07;
 291:Src/stm32f1xx_it.c ****         //steer_temp = TIM2->CCR2 - 1500;
 292:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 293:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 294:Src/stm32f1xx_it.c ****         break;
 295:Src/stm32f1xx_it.c ****       case 0x58:
 296:Src/stm32f1xx_it.c ****         steer_temp = 0x08;
 297:Src/stm32f1xx_it.c ****         //steer_temp = TIM2->CCR1 - 1500;
ARM GAS  /tmp/cc7UAIOT.s 			page 11


 298:Src/stm32f1xx_it.c ****         tx_buf[0] = ((steer_temp&0xff00)>>8);
 299:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 300:Src/stm32f1xx_it.c ****         break;
 301:Src/stm32f1xx_it.c ****     }
 302:Src/stm32f1xx_it.c ****   }
 303:Src/stm32f1xx_it.c **** 
 304:Src/stm32f1xx_it.c ****   if(count == 1){
 289              		.loc 1 304 0
 290 0040 0129     		cmp	r1, #1
 291 0042 02D1     		bne	.L38
 305:Src/stm32f1xx_it.c ****     data_use_r = 0;
 292              		.loc 1 305 0
 293 0044 0027     		movs	r7, #0
 294 0046 934E     		ldr	r6, .L70+16
 295 0048 3770     		strb	r7, [r6]
 296              	.L38:
 306:Src/stm32f1xx_it.c ****   }
 307:Src/stm32f1xx_it.c ****   if(temp_num == buf[3]){
 297              		.loc 1 307 0
 298 004a AB42     		cmp	r3, r5
 299 004c 0AD0     		beq	.L62
 300              	.LVL4:
 301              	.L16:
 308:Src/stm32f1xx_it.c ****     if((buf[0] == 0x05) && count == 5){
 309:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 310:Src/stm32f1xx_it.c ****       if(temp >= 0){
 311:Src/stm32f1xx_it.c ****         TIM1->CCR3 = temp;
 312:Src/stm32f1xx_it.c ****         TIM1->CCR4 = 0;
 313:Src/stm32f1xx_it.c ****         TIM1->CCR1 = temp;
 314:Src/stm32f1xx_it.c ****         TIM1->CCR2 = 0;
 315:Src/stm32f1xx_it.c ****       }else{
 316:Src/stm32f1xx_it.c ****         TIM1->CCR3 = 0;
 317:Src/stm32f1xx_it.c ****         TIM1->CCR4 = -temp;
 318:Src/stm32f1xx_it.c ****         TIM1->CCR1 = 0;
 319:Src/stm32f1xx_it.c ****         TIM1->CCR2 = -temp;
 320:Src/stm32f1xx_it.c ****       }
 321:Src/stm32f1xx_it.c ****       data_use_r = 1;
 322:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x01) && count == 5){
 323:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 324:Src/stm32f1xx_it.c ****       if(temp >= 0){
 325:Src/stm32f1xx_it.c ****         TIM1->CCR3 = temp;
 326:Src/stm32f1xx_it.c ****         TIM1->CCR4 = 0;
 327:Src/stm32f1xx_it.c ****       }else{
 328:Src/stm32f1xx_it.c ****         TIM1->CCR3 = 0;
 329:Src/stm32f1xx_it.c ****         TIM1->CCR4 = -temp;
 330:Src/stm32f1xx_it.c ****       }
 331:Src/stm32f1xx_it.c ****       data_use_r = 1;
 332:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x02) && count == 5){
 333:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 334:Src/stm32f1xx_it.c ****       if(temp >= 0){
 335:Src/stm32f1xx_it.c ****         TIM1->CCR1 = temp;
 336:Src/stm32f1xx_it.c ****         TIM1->CCR2 = 0;
 337:Src/stm32f1xx_it.c ****       }else{
 338:Src/stm32f1xx_it.c ****         TIM1->CCR1 = 0;
 339:Src/stm32f1xx_it.c ****         TIM1->CCR2 = -temp;
 340:Src/stm32f1xx_it.c ****       }
 341:Src/stm32f1xx_it.c ****       data_use_r = 1;
ARM GAS  /tmp/cc7UAIOT.s 			page 12


 342:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x11) && count == 5){
 343:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 344:Src/stm32f1xx_it.c ****       TIM3->CCR4 = 1500 + temp;
 345:Src/stm32f1xx_it.c ****       data_use_r = 1;
 346:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x12) && count == 5){
 347:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 348:Src/stm32f1xx_it.c ****       TIM3->CCR3 = 1500 + temp;
 349:Src/stm32f1xx_it.c ****       data_use_r = 1;
 350:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x13) && count == 5){
 351:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 352:Src/stm32f1xx_it.c ****       TIM3->CCR2 = 1500 + temp;
 353:Src/stm32f1xx_it.c ****       data_use_r = 1;
 354:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x14) && count == 5){
 355:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 356:Src/stm32f1xx_it.c ****       TIM3->CCR1 = 1500 + temp;
 357:Src/stm32f1xx_it.c ****       data_use_r = 1;
 358:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x15) && count == 5){
 359:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 360:Src/stm32f1xx_it.c ****       TIM2->CCR4 = 1500 + temp;
 361:Src/stm32f1xx_it.c ****       data_use_r = 1;
 362:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x16) && count == 5){
 363:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 364:Src/stm32f1xx_it.c ****       TIM2->CCR3 = 1500 + temp;
 365:Src/stm32f1xx_it.c ****       data_use_r = 1;
 366:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x17) && count == 5){
 367:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 368:Src/stm32f1xx_it.c ****       TIM2->CCR2 = 1500 + temp;
 369:Src/stm32f1xx_it.c ****       data_use_r = 1;
 370:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x18) && count == 5){
 371:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 372:Src/stm32f1xx_it.c ****       TIM2->CCR1 = 1500 + temp;
 373:Src/stm32f1xx_it.c ****       data_use_r = 1;
 374:Src/stm32f1xx_it.c ****     }
 375:Src/stm32f1xx_it.c ****   }
 376:Src/stm32f1xx_it.c ****   /* USER CODE END SPI2_IRQn 0 */
 377:Src/stm32f1xx_it.c ****   //HAL_SPI_IRQHandler(&hspi2);
 378:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SPI2_IRQn 1 */
 379:Src/stm32f1xx_it.c ****   /*if(buf[0] == 0x01){
 380:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 381:Src/stm32f1xx_it.c ****     if(temp >= 0){
 382:Src/stm32f1xx_it.c ****       TIM1->CCR3 = temp;
 383:Src/stm32f1xx_it.c ****       TIM1->CCR4 = 0;
 384:Src/stm32f1xx_it.c ****     }else{
 385:Src/stm32f1xx_it.c ****       TIM1->CCR3 = 0;
 386:Src/stm32f1xx_it.c ****       TIM1->CCR4 = -temp;
 387:Src/stm32f1xx_it.c ****     }
 388:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x02){
 389:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 390:Src/stm32f1xx_it.c ****     if(temp >= 0){
 391:Src/stm32f1xx_it.c ****       TIM1->CCR1 = temp;
 392:Src/stm32f1xx_it.c ****       TIM1->CCR2 = 0;
 393:Src/stm32f1xx_it.c ****     }else{
 394:Src/stm32f1xx_it.c ****       TIM1->CCR1 = 0;
 395:Src/stm32f1xx_it.c ****       TIM1->CCR2 = -temp;
 396:Src/stm32f1xx_it.c ****     }
 397:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x11){
 398:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
ARM GAS  /tmp/cc7UAIOT.s 			page 13


 399:Src/stm32f1xx_it.c ****     TIM3->CCR4 = 1500 + temp;
 400:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x12){
 401:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 402:Src/stm32f1xx_it.c ****     TIM3->CCR3 = 1500 + temp;
 403:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x13){
 404:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 405:Src/stm32f1xx_it.c ****     TIM3->CCR2 = 1500 + temp;
 406:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x14){
 407:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 408:Src/stm32f1xx_it.c ****     TIM3->CCR1 = 1500 + temp;
 409:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x15){
 410:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 411:Src/stm32f1xx_it.c ****     TIM2->CCR4 = 1500 + temp;
 412:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x16){
 413:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 414:Src/stm32f1xx_it.c ****     TIM2->CCR3 = 1500 + temp;
 415:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x17){
 416:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 417:Src/stm32f1xx_it.c ****     TIM2->CCR2 = 1500 + temp;
 418:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x18){
 419:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 420:Src/stm32f1xx_it.c ****     TIM2->CCR1 = 1500 + temp;
 421:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x21){
 422:Src/stm32f1xx_it.c ****     if(count == 4){
 423:Src/stm32f1xx_it.c ****       SPI2->DR = ((gray_data_final&0xff00)>>8);
 424:Src/stm32f1xx_it.c ****     }
 425:Src/stm32f1xx_it.c ****     else if(count == 5){
 426:Src/stm32f1xx_it.c ****       SPI2->DR = (gray_data_final&0x00ff);
 427:Src/stm32f1xx_it.c ****     }
 428:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x22){
 429:Src/stm32f1xx_it.c ****     if(count == 4){
 430:Src/stm32f1xx_it.c ****       SPI2->DR = ((gray_data_two_final&0xff00)>>8);
 431:Src/stm32f1xx_it.c ****     }
 432:Src/stm32f1xx_it.c ****     else if(count == 5){
 433:Src/stm32f1xx_it.c ****       SPI2->DR = (gray_data_two_final&0x00ff);
 434:Src/stm32f1xx_it.c ****     }
 435:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x31){
 436:Src/stm32f1xx_it.c ****     if(count == 4){
 437:Src/stm32f1xx_it.c ****       SPI2->DR = ((other_data_final&0xff00)>>8);
 438:Src/stm32f1xx_it.c ****     }
 439:Src/stm32f1xx_it.c ****     else if(count == 5){
 440:Src/stm32f1xx_it.c ****       SPI2->DR = (other_data_final&0x00ff);
 441:Src/stm32f1xx_it.c ****     }
 442:Src/stm32f1xx_it.c ****   }
 443:Src/stm32f1xx_it.c ****   */
 444:Src/stm32f1xx_it.c ****   /* USER CODE END SPI2_IRQn 1 */
 445:Src/stm32f1xx_it.c **** }
 302              		.loc 1 445 0
 303 004e F0BC     		pop	{r4, r5, r6, r7}
 304              	.LCFI3:
 305              		.cfi_remember_state
 306              		.cfi_restore 7
 307              		.cfi_restore 6
 308              		.cfi_restore 5
 309              		.cfi_restore 4
 310              		.cfi_def_cfa_offset 0
 311 0050 7047     		bx	lr
ARM GAS  /tmp/cc7UAIOT.s 			page 14


 312              	.LVL5:
 313              	.L60:
 314              	.LCFI4:
 315              		.cfi_restore_state
 248:Src/stm32f1xx_it.c ****     tx_buf[1] = (gray_data_two_final&0x00ff);
 316              		.loc 1 248 0
 317 0052 914F     		ldr	r7, .L70+20
 318              	.L56:
 319 0054 3F88     		ldrh	r7, [r7]
 320 0056 914E     		ldr	r6, .L70+24
 321 0058 4FEA172C 		lsr	ip, r7, #8
 322 005c 86F800C0 		strb	ip, [r6]
 249:Src/stm32f1xx_it.c ****   }else if((buf[0]&0xf0) == 0x50){
 323              		.loc 1 249 0
 324 0060 7770     		strb	r7, [r6, #1]
 325 0062 EDE7     		b	.L27
 326              	.L62:
 308:Src/stm32f1xx_it.c ****     if((buf[0] == 0x05) && count == 5){
 327              		.loc 1 308 0
 328 0064 052A     		cmp	r2, #5
 329 0066 7FD0     		beq	.L63
 322:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 330              		.loc 1 322 0
 331 0068 012A     		cmp	r2, #1
 332 006a 3FD0     		beq	.L64
 332:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 333              		.loc 1 332 0
 334 006c 022A     		cmp	r2, #2
 335 006e 40F0CA80 		bne	.L45
 332:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 336              		.loc 1 332 0 is_stmt 0 discriminator 1
 337 0072 0529     		cmp	r1, #5
 338 0074 EBD1     		bne	.L16
 339              	.LBB2:
 333:Src/stm32f1xx_it.c ****       if(temp >= 0){
 340              		.loc 1 333 0 is_stmt 1
 341 0076 40EA0420 		orr	r0, r0, r4, lsl #8
 342 007a 00B2     		sxth	r0, r0
 343              	.LVL6:
 334:Src/stm32f1xx_it.c ****         TIM1->CCR1 = temp;
 344              		.loc 1 334 0
 345 007c 0028     		cmp	r0, #0
 336:Src/stm32f1xx_it.c ****       }else{
 346              		.loc 1 336 0
 347 007e 4FF00001 		mov	r1, #0
 335:Src/stm32f1xx_it.c ****         TIM1->CCR2 = 0;
 348              		.loc 1 335 0
 349 0082 874A     		ldr	r2, .L70+28
 334:Src/stm32f1xx_it.c ****         TIM1->CCR1 = temp;
 350              		.loc 1 334 0
 351 0084 C0F2D980 		blt	.L46
 335:Src/stm32f1xx_it.c ****         TIM1->CCR2 = 0;
 352              		.loc 1 335 0
 353 0088 5063     		str	r0, [r2, #52]
 336:Src/stm32f1xx_it.c ****       }else{
 354              		.loc 1 336 0
 355 008a 9163     		str	r1, [r2, #56]
ARM GAS  /tmp/cc7UAIOT.s 			page 15


 356 008c 7BE0     		b	.L42
 357              	.LVL7:
 358              	.L59:
 359              	.LBE2:
 245:Src/stm32f1xx_it.c ****     tx_buf[1] = (gray_data_final&0x00ff);
 360              		.loc 1 245 0
 361 008e 854F     		ldr	r7, .L70+32
 362 0090 E0E7     		b	.L56
 363              	.LVL8:
 364              	.L57:
 211:Src/stm32f1xx_it.c ****     start = true;
 365              		.loc 1 211 0 discriminator 1
 366 0092 002B     		cmp	r3, #0
 367 0094 BBD1     		bne	.L17
 212:Src/stm32f1xx_it.c ****     count ++;
 368              		.loc 1 212 0
 369 0096 0123     		movs	r3, #1
 214:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 1)){      //Êî∂Âà∞ÊéßÂà∂‰ΩçÔºå‰ª£Ë°®Âêé‰∏§‰ΩçË¶ÅÂèëÁöÑ‰∏úË•
 370              		.loc 1 214 0
 371 0098 1125     		movs	r5, #17
 213:Src/stm32f1xx_it.c ****     SPI2->DR = other_status_final;                              //ÂèØÊõøÊç¢ÊàêÁ®ãÂ∫èËøêË°åÂºÄÂÖ≥Áä∂
 372              		.loc 1 213 0
 373 009a 7D4C     		ldr	r4, .L70+12
 212:Src/stm32f1xx_it.c ****     count ++;
 374              		.loc 1 212 0
 375 009c 0370     		strb	r3, [r0]
 213:Src/stm32f1xx_it.c ****     SPI2->DR = other_status_final;                              //ÂèØÊõøÊç¢ÊàêÁ®ãÂ∫èËøêË°åÂºÄÂÖ≥Áä∂
 376              		.loc 1 213 0
 377 009e 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 378 00a0 7A4B     		ldr	r3, .L70+8
 379 00a2 0131     		adds	r1, r1, #1
 380 00a4 C9B2     		uxtb	r1, r1
 381 00a6 2170     		strb	r1, [r4]
 214:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 1)){      //Êî∂Âà∞ÊéßÂà∂‰ΩçÔºå‰ª£Ë°®Âêé‰∏§‰ΩçË¶ÅÂèëÁöÑ‰∏úË•
 382              		.loc 1 214 0
 383 00a8 D560     		str	r5, [r2, #12]
 384 00aa 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 385 00ac 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 386 00ae 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 387 00b0 DD78     		ldrb	r5, [r3, #3]	@ zero_extendqisi2
 388 00b2 B8E7     		b	.L18
 389              	.L58:
 215:Src/stm32f1xx_it.c ****     buf[0] = SPI2->DR;
 390              		.loc 1 215 0 discriminator 1
 391 00b4 764E     		ldr	r6, .L70+12
 392 00b6 3178     		ldrb	r1, [r6]	@ zero_extendqisi2
 393 00b8 0129     		cmp	r1, #1
 394 00ba 25D0     		beq	.L65
 395 00bc 734B     		ldr	r3, .L70+8
 219:Src/stm32f1xx_it.c ****     buf[1] = SPI2->DR;
 396              		.loc 1 219 0 discriminator 1
 397 00be 0229     		cmp	r1, #2
 398 00c0 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 399 00c2 2FD0     		beq	.L66
 223:Src/stm32f1xx_it.c ****     buf[2] = SPI2->DR;
 400              		.loc 1 223 0 discriminator 1
 401 00c4 0329     		cmp	r1, #3
ARM GAS  /tmp/cc7UAIOT.s 			page 16


 402 00c6 38D0     		beq	.L67
 227:Src/stm32f1xx_it.c ****     SPI2->DR = tx_buf[1];
 403              		.loc 1 227 0 discriminator 1
 404 00c8 0429     		cmp	r1, #4
 405 00ca 61D0     		beq	.L68
 230:Src/stm32f1xx_it.c ****     SPI2->DR = (tx_buf[0] + tx_buf[1]) & 0xff;
 406              		.loc 1 230 0 discriminator 1
 407 00cc 0529     		cmp	r1, #5
 408 00ce 65D0     		beq	.L69
 233:Src/stm32f1xx_it.c ****     buf[3] = SPI2->DR;
 409              		.loc 1 233 0 discriminator 1
 410 00d0 0629     		cmp	r1, #6
 411 00d2 A1D1     		bne	.L25
 236:Src/stm32f1xx_it.c ****   }else{
 412              		.loc 1 236 0
 413 00d4 0721     		movs	r1, #7
 234:Src/stm32f1xx_it.c ****     SPI2->DR = data_use_r;
 414              		.loc 1 234 0
 415 00d6 6B48     		ldr	r0, .L70
 235:Src/stm32f1xx_it.c ****     count ++;
 416              		.loc 1 235 0
 417 00d8 6E4C     		ldr	r4, .L70+16
 234:Src/stm32f1xx_it.c ****     SPI2->DR = data_use_r;
 418              		.loc 1 234 0
 419 00da C568     		ldr	r5, [r0, #12]
 235:Src/stm32f1xx_it.c ****     count ++;
 420              		.loc 1 235 0
 421 00dc 2478     		ldrb	r4, [r4]	@ zero_extendqisi2
 234:Src/stm32f1xx_it.c ****     SPI2->DR = data_use_r;
 422              		.loc 1 234 0
 423 00de EDB2     		uxtb	r5, r5
 424 00e0 DD70     		strb	r5, [r3, #3]
 235:Src/stm32f1xx_it.c ****     count ++;
 425              		.loc 1 235 0
 426 00e2 C460     		str	r4, [r0, #12]
 427 00e4 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 428 00e6 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 236:Src/stm32f1xx_it.c ****   }else{
 429              		.loc 1 236 0
 430 00e8 3170     		strb	r1, [r6]
 431 00ea 9CE7     		b	.L18
 432              	.LVL9:
 433              	.L64:
 322:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 434              		.loc 1 322 0 discriminator 1
 435 00ec 0529     		cmp	r1, #5
 436 00ee AED1     		bne	.L16
 437              	.LBB3:
 323:Src/stm32f1xx_it.c ****       if(temp >= 0){
 438              		.loc 1 323 0
 439 00f0 40EA0420 		orr	r0, r0, r4, lsl #8
 440 00f4 00B2     		sxth	r0, r0
 441              	.LVL10:
 324:Src/stm32f1xx_it.c ****         TIM1->CCR3 = temp;
 442              		.loc 1 324 0
 443 00f6 0028     		cmp	r0, #0
 326:Src/stm32f1xx_it.c ****       }else{
ARM GAS  /tmp/cc7UAIOT.s 			page 17


 444              		.loc 1 326 0
 445 00f8 4FF00001 		mov	r1, #0
 325:Src/stm32f1xx_it.c ****         TIM1->CCR4 = 0;
 446              		.loc 1 325 0
 447 00fc 684A     		ldr	r2, .L70+28
 324:Src/stm32f1xx_it.c ****         TIM1->CCR3 = temp;
 448              		.loc 1 324 0
 449 00fe C0F29880 		blt	.L44
 325:Src/stm32f1xx_it.c ****         TIM1->CCR4 = 0;
 450              		.loc 1 325 0
 451 0102 D063     		str	r0, [r2, #60]
 326:Src/stm32f1xx_it.c ****       }else{
 452              		.loc 1 326 0
 453 0104 1164     		str	r1, [r2, #64]
 454 0106 3EE0     		b	.L42
 455              	.LVL11:
 456              	.L65:
 457              	.LBE3:
 218:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 2)){      //Êî∂Âà∞È´ò8‰ΩçÔºåÂèëÈÄÅÊéßÂà∂‰Ωç
 458              		.loc 1 218 0
 459 0108 0227     		movs	r7, #2
 217:Src/stm32f1xx_it.c ****     count ++;
 460              		.loc 1 217 0
 461 010a 1124     		movs	r4, #17
 218:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 2)){      //Êî∂Âà∞È´ò8‰ΩçÔºåÂèëÈÄÅÊéßÂà∂‰Ωç
 462              		.loc 1 218 0
 463 010c 3946     		mov	r1, r7
 216:Src/stm32f1xx_it.c ****     SPI2->DR = other_status_final;
 464              		.loc 1 216 0
 465 010e 5D48     		ldr	r0, .L70
 466 0110 5E4B     		ldr	r3, .L70+8
 467 0112 C268     		ldr	r2, [r0, #12]
 468 0114 D2B2     		uxtb	r2, r2
 469 0116 1A70     		strb	r2, [r3]
 470              	.L55:
 228:Src/stm32f1xx_it.c ****     count ++;
 471              		.loc 1 228 0
 472 0118 C460     		str	r4, [r0, #12]
 473 011a 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 474 011c 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 475 011e DD78     		ldrb	r5, [r3, #3]	@ zero_extendqisi2
 229:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 5)){      //ÂèëÈÄÅÊï∞ÊçÆÊ†°È™å
 476              		.loc 1 229 0
 477 0120 3770     		strb	r7, [r6]
 478 0122 80E7     		b	.L18
 479              	.L66:
 222:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 3)){      //Êî∂Âà∞‰Ωé8‰ΩçÔºåÂèëÈÄÅÊï∞ÊçÆ‰Ωç
 480              		.loc 1 222 0
 481 0124 0327     		movs	r7, #3
 220:Src/stm32f1xx_it.c ****     SPI2->DR = buf[0];
 482              		.loc 1 220 0
 483 0126 574D     		ldr	r5, .L70
 222:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 3)){      //Êî∂Âà∞‰Ωé8‰ΩçÔºåÂèëÈÄÅÊï∞ÊçÆ‰Ωç
 484              		.loc 1 222 0
 485 0128 3946     		mov	r1, r7
 220:Src/stm32f1xx_it.c ****     SPI2->DR = buf[0];
 486              		.loc 1 220 0
ARM GAS  /tmp/cc7UAIOT.s 			page 18


 487 012a EC68     		ldr	r4, [r5, #12]
 488 012c E4B2     		uxtb	r4, r4
 489 012e 5C70     		strb	r4, [r3, #1]
 221:Src/stm32f1xx_it.c ****     count ++;
 490              		.loc 1 221 0
 491 0130 EA60     		str	r2, [r5, #12]
 492 0132 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 493 0134 DD78     		ldrb	r5, [r3, #3]	@ zero_extendqisi2
 222:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 3)){      //Êî∂Âà∞‰Ωé8‰ΩçÔºåÂèëÈÄÅÊï∞ÊçÆ‰Ωç
 494              		.loc 1 222 0
 495 0136 3770     		strb	r7, [r6]
 496 0138 75E7     		b	.L18
 497              	.L67:
 226:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 4)){      //ÂèëÈÄÅÊï∞ÊçÆ‰Ωç
 498              		.loc 1 226 0
 499 013a 0421     		movs	r1, #4
 224:Src/stm32f1xx_it.c ****     SPI2->DR = tx_buf[0];
 500              		.loc 1 224 0
 501 013c 514C     		ldr	r4, .L70
 225:Src/stm32f1xx_it.c ****     count ++;
 502              		.loc 1 225 0
 503 013e 574D     		ldr	r5, .L70+24
 224:Src/stm32f1xx_it.c ****     SPI2->DR = tx_buf[0];
 504              		.loc 1 224 0
 505 0140 E068     		ldr	r0, [r4, #12]
 225:Src/stm32f1xx_it.c ****     count ++;
 506              		.loc 1 225 0
 507 0142 2D78     		ldrb	r5, [r5]	@ zero_extendqisi2
 224:Src/stm32f1xx_it.c ****     SPI2->DR = tx_buf[0];
 508              		.loc 1 224 0
 509 0144 C0B2     		uxtb	r0, r0
 510 0146 9870     		strb	r0, [r3, #2]
 225:Src/stm32f1xx_it.c ****     count ++;
 511              		.loc 1 225 0
 512 0148 E560     		str	r5, [r4, #12]
 513 014a 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 514 014c DD78     		ldrb	r5, [r3, #3]	@ zero_extendqisi2
 226:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 4)){      //ÂèëÈÄÅÊï∞ÊçÆ‰Ωç
 515              		.loc 1 226 0
 516 014e 3170     		strb	r1, [r6]
 517 0150 69E7     		b	.L18
 518              	.LVL12:
 519              	.L61:
 520              	.LBB4:
 252:Src/stm32f1xx_it.c ****       case 0x51:
 521              		.loc 1 252 0
 522 0152 A2F15106 		sub	r6, r2, #81
 523 0156 072E     		cmp	r6, #7
 524 0158 3FF672AF 		bhi	.L27
 525 015c DFE806F0 		tbb	[pc, r6]
 526              	.L30:
 527 0160 4E       		.byte	(.L29-.L30)/2
 528 0161 49       		.byte	(.L31-.L30)/2
 529 0162 44       		.byte	(.L32-.L30)/2
 530 0163 3F       		.byte	(.L33-.L30)/2
 531 0164 3A       		.byte	(.L34-.L30)/2
 532 0165 35       		.byte	(.L35-.L30)/2
ARM GAS  /tmp/cc7UAIOT.s 			page 19


 533 0166 30       		.byte	(.L36-.L30)/2
 534 0167 2B       		.byte	(.L37-.L30)/2
 535              	.LVL13:
 536              		.p2align 1
 537              	.L63:
 538              	.LBE4:
 308:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 539              		.loc 1 308 0 discriminator 1
 540 0168 0529     		cmp	r1, #5
 541 016a 7FF470AF 		bne	.L16
 542              	.LBB5:
 309:Src/stm32f1xx_it.c ****       if(temp >= 0){
 543              		.loc 1 309 0
 544 016e 40EA0420 		orr	r0, r0, r4, lsl #8
 545 0172 00B2     		sxth	r0, r0
 546              	.LVL14:
 310:Src/stm32f1xx_it.c ****         TIM1->CCR3 = temp;
 547              		.loc 1 310 0
 548 0174 0028     		cmp	r0, #0
 312:Src/stm32f1xx_it.c ****         TIM1->CCR1 = temp;
 549              		.loc 1 312 0
 550 0176 4FF00001 		mov	r1, #0
 311:Src/stm32f1xx_it.c ****         TIM1->CCR4 = 0;
 551              		.loc 1 311 0
 552 017a 494A     		ldr	r2, .L70+28
 310:Src/stm32f1xx_it.c ****         TIM1->CCR3 = temp;
 553              		.loc 1 310 0
 554 017c 53DB     		blt	.L41
 311:Src/stm32f1xx_it.c ****         TIM1->CCR4 = 0;
 555              		.loc 1 311 0
 556 017e D063     		str	r0, [r2, #60]
 312:Src/stm32f1xx_it.c ****         TIM1->CCR1 = temp;
 557              		.loc 1 312 0
 558 0180 1164     		str	r1, [r2, #64]
 313:Src/stm32f1xx_it.c ****         TIM1->CCR2 = 0;
 559              		.loc 1 313 0
 560 0182 5063     		str	r0, [r2, #52]
 314:Src/stm32f1xx_it.c ****       }else{
 561              		.loc 1 314 0
 562 0184 9163     		str	r1, [r2, #56]
 563              	.LVL15:
 564              	.L42:
 321:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x01) && count == 5){
 565              		.loc 1 321 0
 566 0186 0122     		movs	r2, #1
 567 0188 424B     		ldr	r3, .L70+16
 568 018a 1A70     		strb	r2, [r3]
 569              	.LBE5:
 570              		.loc 1 445 0
 571 018c F0BC     		pop	{r4, r5, r6, r7}
 572              	.LCFI5:
 573              		.cfi_remember_state
 574              		.cfi_restore 7
 575              		.cfi_restore 6
 576              		.cfi_restore 5
 577              		.cfi_restore 4
 578              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/cc7UAIOT.s 			page 20


 579 018e 7047     		bx	lr
 580              	.L68:
 581              	.LCFI6:
 582              		.cfi_restore_state
 229:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 5)){      //ÂèëÈÄÅÊï∞ÊçÆÊ†°È™å
 583              		.loc 1 229 0
 584 0190 0527     		movs	r7, #5
 228:Src/stm32f1xx_it.c ****     count ++;
 585              		.loc 1 228 0
 586 0192 4249     		ldr	r1, .L70+24
 587 0194 3B48     		ldr	r0, .L70
 588 0196 4C78     		ldrb	r4, [r1, #1]	@ zero_extendqisi2
 229:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 5)){      //ÂèëÈÄÅÊï∞ÊçÆÊ†°È™å
 589              		.loc 1 229 0
 590 0198 3946     		mov	r1, r7
 591 019a BDE7     		b	.L55
 592              	.L69:
 232:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 6)){      //ÂèëÈÄÅÊï∞ÊçÆ‰ΩøÁî®ÊÉÖÂÜµ
 593              		.loc 1 232 0
 594 019c 0621     		movs	r1, #6
 231:Src/stm32f1xx_it.c ****     count ++;
 595              		.loc 1 231 0
 596 019e 3F4C     		ldr	r4, .L70+24
 597 01a0 384D     		ldr	r5, .L70
 598 01a2 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 599 01a4 6478     		ldrb	r4, [r4, #1]	@ zero_extendqisi2
 600 01a6 2044     		add	r0, r0, r4
 601 01a8 C0B2     		uxtb	r0, r0
 602 01aa E860     		str	r0, [r5, #12]
 603 01ac 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 604 01ae 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 605 01b0 DD78     		ldrb	r5, [r3, #3]	@ zero_extendqisi2
 232:Src/stm32f1xx_it.c ****   }else if((start == true) && (count == 6)){      //ÂèëÈÄÅÊï∞ÊçÆ‰ΩøÁî®ÊÉÖÂÜµ
 606              		.loc 1 232 0
 607 01b2 3170     		strb	r1, [r6]
 608 01b4 37E7     		b	.L18
 609              	.LVL16:
 610              	.L37:
 611              	.LBB6:
 298:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 612              		.loc 1 298 0
 613 01b6 4FF40067 		mov	r7, #2048
 614 01ba 384E     		ldr	r6, .L70+24
 615 01bc 3780     		strh	r7, [r6]	@ movhi
 300:Src/stm32f1xx_it.c ****     }
 616              		.loc 1 300 0
 617 01be 3FE7     		b	.L27
 618              	.LVL17:
 619              	.L36:
 292:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 620              		.loc 1 292 0
 621 01c0 4FF4E067 		mov	r7, #1792
 622 01c4 354E     		ldr	r6, .L70+24
 623 01c6 3780     		strh	r7, [r6]	@ movhi
 294:Src/stm32f1xx_it.c ****       case 0x58:
 624              		.loc 1 294 0
 625 01c8 3AE7     		b	.L27
ARM GAS  /tmp/cc7UAIOT.s 			page 21


 626              	.LVL18:
 627              	.L35:
 286:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 628              		.loc 1 286 0
 629 01ca 4FF4C067 		mov	r7, #1536
 630 01ce 334E     		ldr	r6, .L70+24
 631 01d0 3780     		strh	r7, [r6]	@ movhi
 288:Src/stm32f1xx_it.c ****       case 0x57:
 632              		.loc 1 288 0
 633 01d2 35E7     		b	.L27
 634              	.LVL19:
 635              	.L34:
 280:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 636              		.loc 1 280 0
 637 01d4 4FF4A067 		mov	r7, #1280
 638 01d8 304E     		ldr	r6, .L70+24
 639 01da 3780     		strh	r7, [r6]	@ movhi
 282:Src/stm32f1xx_it.c ****       case 0x56:
 640              		.loc 1 282 0
 641 01dc 30E7     		b	.L27
 642              	.LVL20:
 643              	.L33:
 274:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 644              		.loc 1 274 0
 645 01de 4FF48067 		mov	r7, #1024
 646 01e2 2E4E     		ldr	r6, .L70+24
 647 01e4 3780     		strh	r7, [r6]	@ movhi
 276:Src/stm32f1xx_it.c ****       case 0x55:
 648              		.loc 1 276 0
 649 01e6 2BE7     		b	.L27
 650              	.LVL21:
 651              	.L32:
 268:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 652              		.loc 1 268 0
 653 01e8 4FF44077 		mov	r7, #768
 654 01ec 2B4E     		ldr	r6, .L70+24
 655 01ee 3780     		strh	r7, [r6]	@ movhi
 270:Src/stm32f1xx_it.c ****       case 0x54:
 656              		.loc 1 270 0
 657 01f0 26E7     		b	.L27
 658              	.LVL22:
 659              	.L31:
 262:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 660              		.loc 1 262 0
 661 01f2 4FF40077 		mov	r7, #512
 662 01f6 294E     		ldr	r6, .L70+24
 663 01f8 3780     		strh	r7, [r6]	@ movhi
 264:Src/stm32f1xx_it.c ****       case 0x53:
 664              		.loc 1 264 0
 665 01fa 21E7     		b	.L27
 666              	.LVL23:
 667              	.L29:
 256:Src/stm32f1xx_it.c ****         tx_buf[1] = (steer_temp&0x00ff);
 668              		.loc 1 256 0
 669 01fc 4FF48077 		mov	r7, #256
 670 0200 264E     		ldr	r6, .L70+24
 671 0202 3780     		strh	r7, [r6]	@ movhi
ARM GAS  /tmp/cc7UAIOT.s 			page 22


 258:Src/stm32f1xx_it.c ****       case 0x52:
 672              		.loc 1 258 0
 673 0204 1CE7     		b	.L27
 674              	.LVL24:
 675              	.L45:
 676              	.LBE6:
 342:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 677              		.loc 1 342 0
 678 0206 112A     		cmp	r2, #17
 679 0208 1BD1     		bne	.L47
 342:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 680              		.loc 1 342 0 is_stmt 0 discriminator 1
 681 020a 0529     		cmp	r1, #5
 682 020c 7FF41FAF 		bne	.L16
 683              	.LVL25:
 684              	.LBB7:
 345:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x12) && count == 5){
 685              		.loc 1 345 0 is_stmt 1
 686 0210 0121     		movs	r1, #1
 343:Src/stm32f1xx_it.c ****       TIM3->CCR4 = 1500 + temp;
 687              		.loc 1 343 0
 688 0212 40EA0423 		orr	r3, r0, r4, lsl #8
 689              	.LVL26:
 344:Src/stm32f1xx_it.c ****       data_use_r = 1;
 690              		.loc 1 344 0
 691 0216 1BB2     		sxth	r3, r3
 692 0218 2348     		ldr	r0, .L70+36
 693              	.LVL27:
 345:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x12) && count == 5){
 694              		.loc 1 345 0
 695 021a 1E4A     		ldr	r2, .L70+16
 344:Src/stm32f1xx_it.c ****       data_use_r = 1;
 696              		.loc 1 344 0
 697 021c 03F2DC53 		addw	r3, r3, #1500
 698 0220 0364     		str	r3, [r0, #64]
 345:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x12) && count == 5){
 699              		.loc 1 345 0
 700 0222 1170     		strb	r1, [r2]
 701              	.LBE7:
 342:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 702              		.loc 1 342 0
 703 0224 13E7     		b	.L16
 704              	.LVL28:
 705              	.L41:
 706              	.LBB8:
 317:Src/stm32f1xx_it.c ****         TIM1->CCR1 = 0;
 707              		.loc 1 317 0
 708 0226 4342     		negs	r3, r0
 709              	.LVL29:
 316:Src/stm32f1xx_it.c ****         TIM1->CCR4 = -temp;
 710              		.loc 1 316 0
 711 0228 D163     		str	r1, [r2, #60]
 317:Src/stm32f1xx_it.c ****         TIM1->CCR1 = 0;
 712              		.loc 1 317 0
 713 022a 1364     		str	r3, [r2, #64]
 318:Src/stm32f1xx_it.c ****         TIM1->CCR2 = -temp;
 714              		.loc 1 318 0
ARM GAS  /tmp/cc7UAIOT.s 			page 23


 715 022c 5163     		str	r1, [r2, #52]
 319:Src/stm32f1xx_it.c ****       }
 716              		.loc 1 319 0
 717 022e 9363     		str	r3, [r2, #56]
 718 0230 A9E7     		b	.L42
 719              	.LVL30:
 720              	.L44:
 721              	.LBE8:
 722              	.LBB9:
 329:Src/stm32f1xx_it.c ****       }
 723              		.loc 1 329 0
 724 0232 4342     		negs	r3, r0
 725              	.LVL31:
 328:Src/stm32f1xx_it.c ****         TIM1->CCR4 = -temp;
 726              		.loc 1 328 0
 727 0234 D163     		str	r1, [r2, #60]
 329:Src/stm32f1xx_it.c ****       }
 728              		.loc 1 329 0
 729 0236 1364     		str	r3, [r2, #64]
 730 0238 A5E7     		b	.L42
 731              	.LVL32:
 732              	.L46:
 733              	.LBE9:
 734              	.LBB10:
 339:Src/stm32f1xx_it.c ****       }
 735              		.loc 1 339 0
 736 023a 4342     		negs	r3, r0
 737              	.LVL33:
 338:Src/stm32f1xx_it.c ****         TIM1->CCR2 = -temp;
 738              		.loc 1 338 0
 739 023c 5163     		str	r1, [r2, #52]
 339:Src/stm32f1xx_it.c ****       }
 740              		.loc 1 339 0
 741 023e 9363     		str	r3, [r2, #56]
 742 0240 A1E7     		b	.L42
 743              	.LVL34:
 744              	.L47:
 745              	.LBE10:
 346:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 746              		.loc 1 346 0
 747 0242 122A     		cmp	r2, #18
 748 0244 0DD1     		bne	.L48
 346:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 749              		.loc 1 346 0 is_stmt 0 discriminator 1
 750 0246 0529     		cmp	r1, #5
 751 0248 7FF401AF 		bne	.L16
 752              	.LVL35:
 753              	.LBB11:
 349:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x13) && count == 5){
 754              		.loc 1 349 0 is_stmt 1
 755 024c 0121     		movs	r1, #1
 347:Src/stm32f1xx_it.c ****       TIM3->CCR3 = 1500 + temp;
 756              		.loc 1 347 0
 757 024e 40EA0423 		orr	r3, r0, r4, lsl #8
 758              	.LVL36:
 348:Src/stm32f1xx_it.c ****       data_use_r = 1;
 759              		.loc 1 348 0
ARM GAS  /tmp/cc7UAIOT.s 			page 24


 760 0252 1BB2     		sxth	r3, r3
 761 0254 1448     		ldr	r0, .L70+36
 762              	.LVL37:
 349:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x13) && count == 5){
 763              		.loc 1 349 0
 764 0256 0F4A     		ldr	r2, .L70+16
 348:Src/stm32f1xx_it.c ****       data_use_r = 1;
 765              		.loc 1 348 0
 766 0258 03F2DC53 		addw	r3, r3, #1500
 767 025c C363     		str	r3, [r0, #60]
 349:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x13) && count == 5){
 768              		.loc 1 349 0
 769 025e 1170     		strb	r1, [r2]
 770              	.LBE11:
 346:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 771              		.loc 1 346 0
 772 0260 F5E6     		b	.L16
 773              	.LVL38:
 774              	.L48:
 350:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 775              		.loc 1 350 0
 776 0262 132A     		cmp	r2, #19
 777 0264 22D1     		bne	.L49
 350:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 778              		.loc 1 350 0 is_stmt 0 discriminator 1
 779 0266 0529     		cmp	r1, #5
 780 0268 7FF4F1AE 		bne	.L16
 781              	.LVL39:
 782              	.LBB12:
 353:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x14) && count == 5){
 783              		.loc 1 353 0 is_stmt 1
 784 026c 0121     		movs	r1, #1
 351:Src/stm32f1xx_it.c ****       TIM3->CCR2 = 1500 + temp;
 785              		.loc 1 351 0
 786 026e 40EA0423 		orr	r3, r0, r4, lsl #8
 787              	.LVL40:
 352:Src/stm32f1xx_it.c ****       data_use_r = 1;
 788              		.loc 1 352 0
 789 0272 1BB2     		sxth	r3, r3
 790 0274 0C48     		ldr	r0, .L70+36
 791              	.LVL41:
 353:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x14) && count == 5){
 792              		.loc 1 353 0
 793 0276 074A     		ldr	r2, .L70+16
 352:Src/stm32f1xx_it.c ****       data_use_r = 1;
 794              		.loc 1 352 0
 795 0278 03F2DC53 		addw	r3, r3, #1500
 796 027c 8363     		str	r3, [r0, #56]
 353:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x14) && count == 5){
 797              		.loc 1 353 0
 798 027e 1170     		strb	r1, [r2]
 799              	.LBE12:
 350:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 800              		.loc 1 350 0
 801 0280 E5E6     		b	.L16
 802              	.L71:
 803 0282 00BF     		.align	2
ARM GAS  /tmp/cc7UAIOT.s 			page 25


 804              	.L70:
 805 0284 00380040 		.word	1073756160
 806 0288 00000000 		.word	.LANCHOR0
 807 028c 00000000 		.word	.LANCHOR2
 808 0290 00000000 		.word	.LANCHOR1
 809 0294 00000000 		.word	.LANCHOR4
 810 0298 00000000 		.word	gray_data_two_final
 811 029c 00000000 		.word	.LANCHOR3
 812 02a0 002C0140 		.word	1073818624
 813 02a4 00000000 		.word	gray_data_final
 814 02a8 00040040 		.word	1073742848
 815              	.LVL42:
 816              	.L49:
 354:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 817              		.loc 1 354 0
 818 02ac 142A     		cmp	r2, #20
 819 02ae 0DD1     		bne	.L50
 354:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 820              		.loc 1 354 0 is_stmt 0 discriminator 1
 821 02b0 0529     		cmp	r1, #5
 822 02b2 7FF4CCAE 		bne	.L16
 823              	.LVL43:
 824              	.LBB13:
 357:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x15) && count == 5){
 825              		.loc 1 357 0 is_stmt 1
 826 02b6 0121     		movs	r1, #1
 355:Src/stm32f1xx_it.c ****       TIM3->CCR1 = 1500 + temp;
 827              		.loc 1 355 0
 828 02b8 40EA0423 		orr	r3, r0, r4, lsl #8
 829              	.LVL44:
 356:Src/stm32f1xx_it.c ****       data_use_r = 1;
 830              		.loc 1 356 0
 831 02bc 1BB2     		sxth	r3, r3
 832 02be 2648     		ldr	r0, .L72
 833              	.LVL45:
 357:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x15) && count == 5){
 834              		.loc 1 357 0
 835 02c0 264A     		ldr	r2, .L72+4
 356:Src/stm32f1xx_it.c ****       data_use_r = 1;
 836              		.loc 1 356 0
 837 02c2 03F2DC53 		addw	r3, r3, #1500
 838 02c6 4363     		str	r3, [r0, #52]
 357:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x15) && count == 5){
 839              		.loc 1 357 0
 840 02c8 1170     		strb	r1, [r2]
 841              	.LBE13:
 354:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 842              		.loc 1 354 0
 843 02ca C0E6     		b	.L16
 844              	.LVL46:
 845              	.L50:
 358:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 846              		.loc 1 358 0
 847 02cc 152A     		cmp	r2, #21
 848 02ce 0ED1     		bne	.L51
 358:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 849              		.loc 1 358 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/cc7UAIOT.s 			page 26


 850 02d0 0529     		cmp	r1, #5
 851 02d2 7FF4BCAE 		bne	.L16
 852              	.LVL47:
 853              	.LBB14:
 360:Src/stm32f1xx_it.c ****       data_use_r = 1;
 854              		.loc 1 360 0 is_stmt 1
 855 02d6 4FF08045 		mov	r5, #1073741824
 361:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x16) && count == 5){
 856              		.loc 1 361 0
 857 02da 0121     		movs	r1, #1
 359:Src/stm32f1xx_it.c ****       TIM2->CCR4 = 1500 + temp;
 858              		.loc 1 359 0
 859 02dc 40EA0423 		orr	r3, r0, r4, lsl #8
 860              	.LVL48:
 360:Src/stm32f1xx_it.c ****       data_use_r = 1;
 861              		.loc 1 360 0
 862 02e0 1BB2     		sxth	r3, r3
 361:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x16) && count == 5){
 863              		.loc 1 361 0
 864 02e2 1E4A     		ldr	r2, .L72+4
 865              	.LVL49:
 360:Src/stm32f1xx_it.c ****       data_use_r = 1;
 866              		.loc 1 360 0
 867 02e4 03F2DC53 		addw	r3, r3, #1500
 868 02e8 2B64     		str	r3, [r5, #64]
 361:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x16) && count == 5){
 869              		.loc 1 361 0
 870 02ea 1170     		strb	r1, [r2]
 871              	.LBE14:
 358:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 872              		.loc 1 358 0
 873 02ec AFE6     		b	.L16
 874              	.LVL50:
 875              	.L51:
 362:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 876              		.loc 1 362 0
 877 02ee 162A     		cmp	r2, #22
 878 02f0 0ED1     		bne	.L52
 362:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 879              		.loc 1 362 0 is_stmt 0 discriminator 1
 880 02f2 0529     		cmp	r1, #5
 881 02f4 7FF4ABAE 		bne	.L16
 882              	.LVL51:
 883              	.LBB15:
 364:Src/stm32f1xx_it.c ****       data_use_r = 1;
 884              		.loc 1 364 0 is_stmt 1
 885 02f8 4FF08045 		mov	r5, #1073741824
 365:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x17) && count == 5){
 886              		.loc 1 365 0
 887 02fc 0121     		movs	r1, #1
 363:Src/stm32f1xx_it.c ****       TIM2->CCR3 = 1500 + temp;
 888              		.loc 1 363 0
 889 02fe 40EA0423 		orr	r3, r0, r4, lsl #8
 890              	.LVL52:
 364:Src/stm32f1xx_it.c ****       data_use_r = 1;
 891              		.loc 1 364 0
 892 0302 1BB2     		sxth	r3, r3
ARM GAS  /tmp/cc7UAIOT.s 			page 27


 365:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x17) && count == 5){
 893              		.loc 1 365 0
 894 0304 154A     		ldr	r2, .L72+4
 895              	.LVL53:
 364:Src/stm32f1xx_it.c ****       data_use_r = 1;
 896              		.loc 1 364 0
 897 0306 03F2DC53 		addw	r3, r3, #1500
 898 030a EB63     		str	r3, [r5, #60]
 365:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x17) && count == 5){
 899              		.loc 1 365 0
 900 030c 1170     		strb	r1, [r2]
 901              	.LBE15:
 362:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 902              		.loc 1 362 0
 903 030e 9EE6     		b	.L16
 904              	.LVL54:
 905              	.L52:
 366:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 906              		.loc 1 366 0
 907 0310 172A     		cmp	r2, #23
 908 0312 0ED1     		bne	.L53
 366:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 909              		.loc 1 366 0 is_stmt 0 discriminator 1
 910 0314 0529     		cmp	r1, #5
 911 0316 7FF49AAE 		bne	.L16
 912              	.LVL55:
 913              	.LBB16:
 368:Src/stm32f1xx_it.c ****       data_use_r = 1;
 914              		.loc 1 368 0 is_stmt 1
 915 031a 4FF08045 		mov	r5, #1073741824
 369:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x18) && count == 5){
 916              		.loc 1 369 0
 917 031e 0121     		movs	r1, #1
 367:Src/stm32f1xx_it.c ****       TIM2->CCR2 = 1500 + temp;
 918              		.loc 1 367 0
 919 0320 40EA0423 		orr	r3, r0, r4, lsl #8
 920              	.LVL56:
 368:Src/stm32f1xx_it.c ****       data_use_r = 1;
 921              		.loc 1 368 0
 922 0324 1BB2     		sxth	r3, r3
 369:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x18) && count == 5){
 923              		.loc 1 369 0
 924 0326 0D4A     		ldr	r2, .L72+4
 925              	.LVL57:
 368:Src/stm32f1xx_it.c ****       data_use_r = 1;
 926              		.loc 1 368 0
 927 0328 03F2DC53 		addw	r3, r3, #1500
 928 032c AB63     		str	r3, [r5, #56]
 369:Src/stm32f1xx_it.c ****     }else if((buf[0] == 0x18) && count == 5){
 929              		.loc 1 369 0
 930 032e 1170     		strb	r1, [r2]
 931              	.LBE16:
 366:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 932              		.loc 1 366 0
 933 0330 8DE6     		b	.L16
 934              	.LVL58:
 935              	.L53:
ARM GAS  /tmp/cc7UAIOT.s 			page 28


 370:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 936              		.loc 1 370 0
 937 0332 182A     		cmp	r2, #24
 938 0334 7FF48BAE 		bne	.L16
 370:Src/stm32f1xx_it.c ****       int16_t temp = (buf[1]<<8 | buf[2]);
 939              		.loc 1 370 0 is_stmt 0 discriminator 1
 940 0338 0529     		cmp	r1, #5
 941 033a 7FF488AE 		bne	.L16
 942              	.LVL59:
 943              	.LBB17:
 372:Src/stm32f1xx_it.c ****       data_use_r = 1;
 944              		.loc 1 372 0 is_stmt 1
 945 033e 4FF08045 		mov	r5, #1073741824
 373:Src/stm32f1xx_it.c ****     }
 946              		.loc 1 373 0
 947 0342 0121     		movs	r1, #1
 371:Src/stm32f1xx_it.c ****       TIM2->CCR1 = 1500 + temp;
 948              		.loc 1 371 0
 949 0344 40EA0423 		orr	r3, r0, r4, lsl #8
 950              	.LVL60:
 372:Src/stm32f1xx_it.c ****       data_use_r = 1;
 951              		.loc 1 372 0
 952 0348 1BB2     		sxth	r3, r3
 373:Src/stm32f1xx_it.c ****     }
 953              		.loc 1 373 0
 954 034a 044A     		ldr	r2, .L72+4
 955              	.LVL61:
 372:Src/stm32f1xx_it.c ****       data_use_r = 1;
 956              		.loc 1 372 0
 957 034c 03F2DC53 		addw	r3, r3, #1500
 958 0350 6B63     		str	r3, [r5, #52]
 373:Src/stm32f1xx_it.c ****     }
 959              		.loc 1 373 0
 960 0352 1170     		strb	r1, [r2]
 961              	.LBE17:
 962              		.loc 1 445 0
 963 0354 7BE6     		b	.L16
 964              	.L73:
 965 0356 00BF     		.align	2
 966              	.L72:
 967 0358 00040040 		.word	1073742848
 968 035c 00000000 		.word	.LANCHOR4
 969              		.cfi_endproc
 970              	.LFE75:
 972              		.section	.bss.buf.7225,"aw",%nobits
 973              		.align	2
 974              		.set	.LANCHOR2,. + 0
 977              	buf.7225:
 978 0000 00000000 		.space	5
 978      00
 979              		.section	.bss.count,"aw",%nobits
 980              		.set	.LANCHOR1,. + 0
 983              	count:
 984 0000 00       		.space	1
 985              		.section	.bss.data_use_r.7224,"aw",%nobits
 986              		.set	.LANCHOR4,. + 0
 989              	data_use_r.7224:
ARM GAS  /tmp/cc7UAIOT.s 			page 29


 990 0000 00       		.space	1
 991              		.section	.bss.start.7223,"aw",%nobits
 992              		.set	.LANCHOR0,. + 0
 995              	start.7223:
 996 0000 00       		.space	1
 997              		.section	.data.tx_buf.7226,"aw",%progbits
 998              		.align	2
 999              		.set	.LANCHOR3,. + 0
 1002              	tx_buf.7226:
 1003 0000 01       		.byte	1
 1004 0001 02       		.byte	2
 1005              		.text
 1006              	.Letext0:
 1007              		.file 2 "Inc/main.h"
 1008              		.file 3 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/machine/_default_type
 1009              		.file 4 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/_stdint.h"
 1010              		.file 5 "Drivers/CMSIS/Include/core_cm3.h"
 1011              		.file 6 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 1012              		.file 7 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 1013              		.file 8 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/lock.h"
 1014              		.file 9 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/_types.h"
 1015              		.file 10 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/lib/gcc/arm-none-eabi/7.3.1/include/stddef
 1016              		.file 11 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/reent.h"
 1017              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 1018              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 1019              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_spi.h"
 1020              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 1021              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_cortex.h"
ARM GAS  /tmp/cc7UAIOT.s 			page 30


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f1xx_it.c
     /tmp/cc7UAIOT.s:16     .text.NMI_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:24     .text.NMI_Handler:0000000000000000 NMI_Handler
     /tmp/cc7UAIOT.s:38     .text.HardFault_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:46     .text.HardFault_Handler:0000000000000000 HardFault_Handler
     /tmp/cc7UAIOT.s:60     .text.MemManage_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:68     .text.MemManage_Handler:0000000000000000 MemManage_Handler
     /tmp/cc7UAIOT.s:82     .text.BusFault_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:90     .text.BusFault_Handler:0000000000000000 BusFault_Handler
     /tmp/cc7UAIOT.s:104    .text.UsageFault_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:112    .text.UsageFault_Handler:0000000000000000 UsageFault_Handler
     /tmp/cc7UAIOT.s:126    .text.SVC_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:134    .text.SVC_Handler:0000000000000000 SVC_Handler
     /tmp/cc7UAIOT.s:145    .text.DebugMon_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:153    .text.DebugMon_Handler:0000000000000000 DebugMon_Handler
     /tmp/cc7UAIOT.s:164    .text.PendSV_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:172    .text.PendSV_Handler:0000000000000000 PendSV_Handler
     /tmp/cc7UAIOT.s:183    .text.SysTick_Handler:0000000000000000 $t
     /tmp/cc7UAIOT.s:191    .text.SysTick_Handler:0000000000000000 SysTick_Handler
     /tmp/cc7UAIOT.s:219    .text.SPI2_IRQHandler:0000000000000000 $t
     /tmp/cc7UAIOT.s:227    .text.SPI2_IRQHandler:0000000000000000 SPI2_IRQHandler
     /tmp/cc7UAIOT.s:527    .text.SPI2_IRQHandler:0000000000000160 $d
     /tmp/cc7UAIOT.s:536    .text.SPI2_IRQHandler:0000000000000168 $t
     /tmp/cc7UAIOT.s:805    .text.SPI2_IRQHandler:0000000000000284 $d
     /tmp/cc7UAIOT.s:818    .text.SPI2_IRQHandler:00000000000002ac $t
     /tmp/cc7UAIOT.s:967    .text.SPI2_IRQHandler:0000000000000358 $d
     /tmp/cc7UAIOT.s:973    .bss.buf.7225:0000000000000000 $d
     /tmp/cc7UAIOT.s:977    .bss.buf.7225:0000000000000000 buf.7225
     /tmp/cc7UAIOT.s:983    .bss.count:0000000000000000 count
     /tmp/cc7UAIOT.s:984    .bss.count:0000000000000000 $d
     /tmp/cc7UAIOT.s:989    .bss.data_use_r.7224:0000000000000000 data_use_r.7224
     /tmp/cc7UAIOT.s:990    .bss.data_use_r.7224:0000000000000000 $d
     /tmp/cc7UAIOT.s:995    .bss.start.7223:0000000000000000 start.7223
     /tmp/cc7UAIOT.s:996    .bss.start.7223:0000000000000000 $d
     /tmp/cc7UAIOT.s:998    .data.tx_buf.7226:0000000000000000 $d
     /tmp/cc7UAIOT.s:1002   .data.tx_buf.7226:0000000000000000 tx_buf.7226

UNDEFINED SYMBOLS
HAL_IncTick
HAL_SYSTICK_IRQHandler
gray_data_two_final
gray_data_final
