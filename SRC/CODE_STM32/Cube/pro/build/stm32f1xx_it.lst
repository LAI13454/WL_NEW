ARM GAS  /tmp/ccZ9uWVr.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 2
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32f1xx_it.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.NMI_Handler,"ax",%progbits
  16              		.align	1
  17              		.p2align 2,,3
  18              		.global	NMI_Handler
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	NMI_Handler:
  25              	.LFB66:
  26              		.file 1 "Src/stm32f1xx_it.c"
   1:Src/stm32f1xx_it.c **** /**
   2:Src/stm32f1xx_it.c ****   ******************************************************************************
   3:Src/stm32f1xx_it.c ****   * @file    stm32f1xx_it.c
   4:Src/stm32f1xx_it.c ****   * @brief   Interrupt Service Routines.
   5:Src/stm32f1xx_it.c ****   ******************************************************************************
   6:Src/stm32f1xx_it.c ****   *
   7:Src/stm32f1xx_it.c ****   * COPYRIGHT(c) 2018 STMicroelectronics
   8:Src/stm32f1xx_it.c ****   *
   9:Src/stm32f1xx_it.c ****   * Redistribution and use in source and binary forms, with or without modification,
  10:Src/stm32f1xx_it.c ****   * are permitted provided that the following conditions are met:
  11:Src/stm32f1xx_it.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  12:Src/stm32f1xx_it.c ****   *      this list of conditions and the following disclaimer.
  13:Src/stm32f1xx_it.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  14:Src/stm32f1xx_it.c ****   *      this list of conditions and the following disclaimer in the documentation
  15:Src/stm32f1xx_it.c ****   *      and/or other materials provided with the distribution.
  16:Src/stm32f1xx_it.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  17:Src/stm32f1xx_it.c ****   *      may be used to endorse or promote products derived from this software
  18:Src/stm32f1xx_it.c ****   *      without specific prior written permission.
  19:Src/stm32f1xx_it.c ****   *
  20:Src/stm32f1xx_it.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:Src/stm32f1xx_it.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:Src/stm32f1xx_it.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  23:Src/stm32f1xx_it.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  24:Src/stm32f1xx_it.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  25:Src/stm32f1xx_it.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  26:Src/stm32f1xx_it.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  27:Src/stm32f1xx_it.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  28:Src/stm32f1xx_it.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29:Src/stm32f1xx_it.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30:Src/stm32f1xx_it.c ****   *
  31:Src/stm32f1xx_it.c ****   ******************************************************************************
  32:Src/stm32f1xx_it.c ****   */
ARM GAS  /tmp/ccZ9uWVr.s 			page 2


  33:Src/stm32f1xx_it.c **** /* Includes ------------------------------------------------------------------*/
  34:Src/stm32f1xx_it.c **** #include "stm32f1xx_hal.h"
  35:Src/stm32f1xx_it.c **** #include "stm32f1xx.h"
  36:Src/stm32f1xx_it.c **** #include "stm32f1xx_it.h"
  37:Src/stm32f1xx_it.c **** 
  38:Src/stm32f1xx_it.c **** /* USER CODE BEGIN 0 */
  39:Src/stm32f1xx_it.c **** 
  40:Src/stm32f1xx_it.c **** /* USER CODE END 0 */
  41:Src/stm32f1xx_it.c **** 
  42:Src/stm32f1xx_it.c **** /* External variables --------------------------------------------------------*/
  43:Src/stm32f1xx_it.c **** extern SPI_HandleTypeDef hspi2;
  44:Src/stm32f1xx_it.c **** 
  45:Src/stm32f1xx_it.c **** /******************************************************************************/
  46:Src/stm32f1xx_it.c **** /*            Cortex-M3 Processor Interruption and Exception Handlers         */ 
  47:Src/stm32f1xx_it.c **** /******************************************************************************/
  48:Src/stm32f1xx_it.c **** 
  49:Src/stm32f1xx_it.c **** /**
  50:Src/stm32f1xx_it.c **** * @brief This function handles Non maskable interrupt.
  51:Src/stm32f1xx_it.c **** */
  52:Src/stm32f1xx_it.c **** void NMI_Handler(void)
  53:Src/stm32f1xx_it.c **** {
  27              		.loc 1 53 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  54:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN NonMaskableInt_IRQn 0 */
  55:Src/stm32f1xx_it.c **** 
  56:Src/stm32f1xx_it.c ****   /* USER CODE END NonMaskableInt_IRQn 0 */
  57:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  58:Src/stm32f1xx_it.c **** 
  59:Src/stm32f1xx_it.c ****   /* USER CODE END NonMaskableInt_IRQn 1 */
  60:Src/stm32f1xx_it.c **** }
  32              		.loc 1 60 0
  33 0000 7047     		bx	lr
  34              		.cfi_endproc
  35              	.LFE66:
  37 0002 00BF     		.section	.text.HardFault_Handler,"ax",%progbits
  38              		.align	1
  39              		.p2align 2,,3
  40              		.global	HardFault_Handler
  41              		.syntax unified
  42              		.thumb
  43              		.thumb_func
  44              		.fpu softvfp
  46              	HardFault_Handler:
  47              	.LFB67:
  61:Src/stm32f1xx_it.c **** 
  62:Src/stm32f1xx_it.c **** /**
  63:Src/stm32f1xx_it.c **** * @brief This function handles Hard fault interrupt.
  64:Src/stm32f1xx_it.c **** */
  65:Src/stm32f1xx_it.c **** void HardFault_Handler(void)
  66:Src/stm32f1xx_it.c **** {
  48              		.loc 1 66 0
  49              		.cfi_startproc
  50              		@ Volatile: function does not return.
  51              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccZ9uWVr.s 			page 3


  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53              		@ link register save eliminated.
  54              	.L4:
  55 0000 FEE7     		b	.L4
  56              		.cfi_endproc
  57              	.LFE67:
  59 0002 00BF     		.section	.text.MemManage_Handler,"ax",%progbits
  60              		.align	1
  61              		.p2align 2,,3
  62              		.global	MemManage_Handler
  63              		.syntax unified
  64              		.thumb
  65              		.thumb_func
  66              		.fpu softvfp
  68              	MemManage_Handler:
  69              	.LFB68:
  67:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN HardFault_IRQn 0 */
  68:Src/stm32f1xx_it.c **** 
  69:Src/stm32f1xx_it.c ****   /* USER CODE END HardFault_IRQn 0 */
  70:Src/stm32f1xx_it.c ****   while (1)
  71:Src/stm32f1xx_it.c ****   {
  72:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_HardFault_IRQn 0 */
  73:Src/stm32f1xx_it.c ****     /* USER CODE END W1_HardFault_IRQn 0 */
  74:Src/stm32f1xx_it.c ****   }
  75:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN HardFault_IRQn 1 */
  76:Src/stm32f1xx_it.c **** 
  77:Src/stm32f1xx_it.c ****   /* USER CODE END HardFault_IRQn 1 */
  78:Src/stm32f1xx_it.c **** }
  79:Src/stm32f1xx_it.c **** 
  80:Src/stm32f1xx_it.c **** /**
  81:Src/stm32f1xx_it.c **** * @brief This function handles Memory management fault.
  82:Src/stm32f1xx_it.c **** */
  83:Src/stm32f1xx_it.c **** void MemManage_Handler(void)
  84:Src/stm32f1xx_it.c **** {
  70              		.loc 1 84 0
  71              		.cfi_startproc
  72              		@ Volatile: function does not return.
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75              		@ link register save eliminated.
  76              	.L6:
  77 0000 FEE7     		b	.L6
  78              		.cfi_endproc
  79              	.LFE68:
  81 0002 00BF     		.section	.text.BusFault_Handler,"ax",%progbits
  82              		.align	1
  83              		.p2align 2,,3
  84              		.global	BusFault_Handler
  85              		.syntax unified
  86              		.thumb
  87              		.thumb_func
  88              		.fpu softvfp
  90              	BusFault_Handler:
  91              	.LFB69:
  85:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN MemoryManagement_IRQn 0 */
  86:Src/stm32f1xx_it.c **** 
  87:Src/stm32f1xx_it.c ****   /* USER CODE END MemoryManagement_IRQn 0 */
ARM GAS  /tmp/ccZ9uWVr.s 			page 4


  88:Src/stm32f1xx_it.c ****   while (1)
  89:Src/stm32f1xx_it.c ****   {
  90:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
  91:Src/stm32f1xx_it.c ****     /* USER CODE END W1_MemoryManagement_IRQn 0 */
  92:Src/stm32f1xx_it.c ****   }
  93:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN MemoryManagement_IRQn 1 */
  94:Src/stm32f1xx_it.c **** 
  95:Src/stm32f1xx_it.c ****   /* USER CODE END MemoryManagement_IRQn 1 */
  96:Src/stm32f1xx_it.c **** }
  97:Src/stm32f1xx_it.c **** 
  98:Src/stm32f1xx_it.c **** /**
  99:Src/stm32f1xx_it.c **** * @brief This function handles Prefetch fault, memory access fault.
 100:Src/stm32f1xx_it.c **** */
 101:Src/stm32f1xx_it.c **** void BusFault_Handler(void)
 102:Src/stm32f1xx_it.c **** {
  92              		.loc 1 102 0
  93              		.cfi_startproc
  94              		@ Volatile: function does not return.
  95              		@ args = 0, pretend = 0, frame = 0
  96              		@ frame_needed = 0, uses_anonymous_args = 0
  97              		@ link register save eliminated.
  98              	.L8:
  99 0000 FEE7     		b	.L8
 100              		.cfi_endproc
 101              	.LFE69:
 103 0002 00BF     		.section	.text.UsageFault_Handler,"ax",%progbits
 104              		.align	1
 105              		.p2align 2,,3
 106              		.global	UsageFault_Handler
 107              		.syntax unified
 108              		.thumb
 109              		.thumb_func
 110              		.fpu softvfp
 112              	UsageFault_Handler:
 113              	.LFB70:
 103:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN BusFault_IRQn 0 */
 104:Src/stm32f1xx_it.c **** 
 105:Src/stm32f1xx_it.c ****   /* USER CODE END BusFault_IRQn 0 */
 106:Src/stm32f1xx_it.c ****   while (1)
 107:Src/stm32f1xx_it.c ****   {
 108:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_BusFault_IRQn 0 */
 109:Src/stm32f1xx_it.c ****     /* USER CODE END W1_BusFault_IRQn 0 */
 110:Src/stm32f1xx_it.c ****   }
 111:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN BusFault_IRQn 1 */
 112:Src/stm32f1xx_it.c **** 
 113:Src/stm32f1xx_it.c ****   /* USER CODE END BusFault_IRQn 1 */
 114:Src/stm32f1xx_it.c **** }
 115:Src/stm32f1xx_it.c **** 
 116:Src/stm32f1xx_it.c **** /**
 117:Src/stm32f1xx_it.c **** * @brief This function handles Undefined instruction or illegal state.
 118:Src/stm32f1xx_it.c **** */
 119:Src/stm32f1xx_it.c **** void UsageFault_Handler(void)
 120:Src/stm32f1xx_it.c **** {
 114              		.loc 1 120 0
 115              		.cfi_startproc
 116              		@ Volatile: function does not return.
 117              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccZ9uWVr.s 			page 5


 118              		@ frame_needed = 0, uses_anonymous_args = 0
 119              		@ link register save eliminated.
 120              	.L10:
 121 0000 FEE7     		b	.L10
 122              		.cfi_endproc
 123              	.LFE70:
 125 0002 00BF     		.section	.text.SVC_Handler,"ax",%progbits
 126              		.align	1
 127              		.p2align 2,,3
 128              		.global	SVC_Handler
 129              		.syntax unified
 130              		.thumb
 131              		.thumb_func
 132              		.fpu softvfp
 134              	SVC_Handler:
 135              	.LFB77:
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140 0000 7047     		bx	lr
 141              		.cfi_endproc
 142              	.LFE77:
 144 0002 00BF     		.section	.text.DebugMon_Handler,"ax",%progbits
 145              		.align	1
 146              		.p2align 2,,3
 147              		.global	DebugMon_Handler
 148              		.syntax unified
 149              		.thumb
 150              		.thumb_func
 151              		.fpu softvfp
 153              	DebugMon_Handler:
 154              	.LFB79:
 155              		.cfi_startproc
 156              		@ args = 0, pretend = 0, frame = 0
 157              		@ frame_needed = 0, uses_anonymous_args = 0
 158              		@ link register save eliminated.
 159 0000 7047     		bx	lr
 160              		.cfi_endproc
 161              	.LFE79:
 163 0002 00BF     		.section	.text.PendSV_Handler,"ax",%progbits
 164              		.align	1
 165              		.p2align 2,,3
 166              		.global	PendSV_Handler
 167              		.syntax unified
 168              		.thumb
 169              		.thumb_func
 170              		.fpu softvfp
 172              	PendSV_Handler:
 173              	.LFB81:
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178 0000 7047     		bx	lr
 179              		.cfi_endproc
 180              	.LFE81:
ARM GAS  /tmp/ccZ9uWVr.s 			page 6


 182 0002 00BF     		.section	.text.SysTick_Handler,"ax",%progbits
 183              		.align	1
 184              		.p2align 2,,3
 185              		.global	SysTick_Handler
 186              		.syntax unified
 187              		.thumb
 188              		.thumb_func
 189              		.fpu softvfp
 191              	SysTick_Handler:
 192              	.LFB74:
 121:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN UsageFault_IRQn 0 */
 122:Src/stm32f1xx_it.c **** 
 123:Src/stm32f1xx_it.c ****   /* USER CODE END UsageFault_IRQn 0 */
 124:Src/stm32f1xx_it.c ****   while (1)
 125:Src/stm32f1xx_it.c ****   {
 126:Src/stm32f1xx_it.c ****     /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
 127:Src/stm32f1xx_it.c ****     /* USER CODE END W1_UsageFault_IRQn 0 */
 128:Src/stm32f1xx_it.c ****   }
 129:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN UsageFault_IRQn 1 */
 130:Src/stm32f1xx_it.c **** 
 131:Src/stm32f1xx_it.c ****   /* USER CODE END UsageFault_IRQn 1 */
 132:Src/stm32f1xx_it.c **** }
 133:Src/stm32f1xx_it.c **** 
 134:Src/stm32f1xx_it.c **** /**
 135:Src/stm32f1xx_it.c **** * @brief This function handles System service call via SWI instruction.
 136:Src/stm32f1xx_it.c **** */
 137:Src/stm32f1xx_it.c **** void SVC_Handler(void)
 138:Src/stm32f1xx_it.c **** {
 139:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SVCall_IRQn 0 */
 140:Src/stm32f1xx_it.c **** 
 141:Src/stm32f1xx_it.c ****   /* USER CODE END SVCall_IRQn 0 */
 142:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SVCall_IRQn 1 */
 143:Src/stm32f1xx_it.c **** 
 144:Src/stm32f1xx_it.c ****   /* USER CODE END SVCall_IRQn 1 */
 145:Src/stm32f1xx_it.c **** }
 146:Src/stm32f1xx_it.c **** 
 147:Src/stm32f1xx_it.c **** /**
 148:Src/stm32f1xx_it.c **** * @brief This function handles Debug monitor.
 149:Src/stm32f1xx_it.c **** */
 150:Src/stm32f1xx_it.c **** void DebugMon_Handler(void)
 151:Src/stm32f1xx_it.c **** {
 152:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN DebugMonitor_IRQn 0 */
 153:Src/stm32f1xx_it.c **** 
 154:Src/stm32f1xx_it.c ****   /* USER CODE END DebugMonitor_IRQn 0 */
 155:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN DebugMonitor_IRQn 1 */
 156:Src/stm32f1xx_it.c **** 
 157:Src/stm32f1xx_it.c ****   /* USER CODE END DebugMonitor_IRQn 1 */
 158:Src/stm32f1xx_it.c **** }
 159:Src/stm32f1xx_it.c **** 
 160:Src/stm32f1xx_it.c **** /**
 161:Src/stm32f1xx_it.c **** * @brief This function handles Pendable request for system service.
 162:Src/stm32f1xx_it.c **** */
 163:Src/stm32f1xx_it.c **** void PendSV_Handler(void)
 164:Src/stm32f1xx_it.c **** {
 165:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN PendSV_IRQn 0 */
 166:Src/stm32f1xx_it.c **** 
 167:Src/stm32f1xx_it.c ****   /* USER CODE END PendSV_IRQn 0 */
ARM GAS  /tmp/ccZ9uWVr.s 			page 7


 168:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN PendSV_IRQn 1 */
 169:Src/stm32f1xx_it.c **** 
 170:Src/stm32f1xx_it.c ****   /* USER CODE END PendSV_IRQn 1 */
 171:Src/stm32f1xx_it.c **** }
 172:Src/stm32f1xx_it.c **** 
 173:Src/stm32f1xx_it.c **** /**
 174:Src/stm32f1xx_it.c **** * @brief This function handles System tick timer.
 175:Src/stm32f1xx_it.c **** */
 176:Src/stm32f1xx_it.c **** void SysTick_Handler(void)
 177:Src/stm32f1xx_it.c **** {
 193              		.loc 1 177 0
 194              		.cfi_startproc
 195              		@ args = 0, pretend = 0, frame = 0
 196              		@ frame_needed = 0, uses_anonymous_args = 0
 197              		.loc 1 177 0
 198 0000 08B5     		push	{r3, lr}
 199              	.LCFI0:
 200              		.cfi_def_cfa_offset 8
 201              		.cfi_offset 3, -8
 202              		.cfi_offset 14, -4
 178:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SysTick_IRQn 0 */
 179:Src/stm32f1xx_it.c **** 
 180:Src/stm32f1xx_it.c ****   /* USER CODE END SysTick_IRQn 0 */
 181:Src/stm32f1xx_it.c ****   HAL_IncTick();
 203              		.loc 1 181 0
 204 0002 FFF7FEFF 		bl	HAL_IncTick
 205              	.LVL0:
 182:Src/stm32f1xx_it.c ****   HAL_SYSTICK_IRQHandler();
 183:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SysTick_IRQn 1 */
 184:Src/stm32f1xx_it.c **** 
 185:Src/stm32f1xx_it.c ****   /* USER CODE END SysTick_IRQn 1 */
 186:Src/stm32f1xx_it.c **** }
 206              		.loc 1 186 0
 207 0006 BDE80840 		pop	{r3, lr}
 208              	.LCFI1:
 209              		.cfi_restore 14
 210              		.cfi_restore 3
 211              		.cfi_def_cfa_offset 0
 182:Src/stm32f1xx_it.c ****   HAL_SYSTICK_IRQHandler();
 212              		.loc 1 182 0
 213 000a FFF7FEBF 		b	HAL_SYSTICK_IRQHandler
 214              	.LVL1:
 215              		.cfi_endproc
 216              	.LFE74:
 218 000e 00BF     		.section	.text.SPI2_IRQHandler,"ax",%progbits
 219              		.align	1
 220              		.p2align 2,,3
 221              		.global	SPI2_IRQHandler
 222              		.syntax unified
 223              		.thumb
 224              		.thumb_func
 225              		.fpu softvfp
 227              	SPI2_IRQHandler:
 228              	.LFB75:
 187:Src/stm32f1xx_it.c **** 
 188:Src/stm32f1xx_it.c **** /******************************************************************************/
 189:Src/stm32f1xx_it.c **** /* STM32F1xx Peripheral Interrupt Handlers                                    */
ARM GAS  /tmp/ccZ9uWVr.s 			page 8


 190:Src/stm32f1xx_it.c **** /* Add here the Interrupt Handlers for the used peripherals.                  */
 191:Src/stm32f1xx_it.c **** /* For the available peripheral interrupt handler names,                      */
 192:Src/stm32f1xx_it.c **** /* please refer to the startup file (startup_stm32f1xx.s).                    */
 193:Src/stm32f1xx_it.c **** /******************************************************************************/
 194:Src/stm32f1xx_it.c **** 
 195:Src/stm32f1xx_it.c **** /**
 196:Src/stm32f1xx_it.c **** * @brief This function handles SPI2 global interrupt.
 197:Src/stm32f1xx_it.c **** */
 198:Src/stm32f1xx_it.c **** void SPI2_IRQHandler(void)
 199:Src/stm32f1xx_it.c **** {
 229              		.loc 1 199 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 200:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SPI2_IRQn 0 */
 201:Src/stm32f1xx_it.c ****   extern uint16_t gray_data_final;
 202:Src/stm32f1xx_it.c ****   extern uint16_t gray_data_two_final;
 203:Src/stm32f1xx_it.c ****   extern uint16_t other_data_final;
 204:Src/stm32f1xx_it.c ****   
 205:Src/stm32f1xx_it.c ****   static bool start=false;
 206:Src/stm32f1xx_it.c ****   static uint8_t buf[5] = {0};
 207:Src/stm32f1xx_it.c ****   static uint8_t count =0;
 208:Src/stm32f1xx_it.c ****   if((SPI2->DR == 0xaa) && (start == false))
 233              		.loc 1 208 0
 234 0000 804A     		ldr	r2, .L66
 199:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SPI2_IRQn 0 */
 235              		.loc 1 199 0
 236 0002 38B5     		push	{r3, r4, r5, lr}
 237              	.LCFI2:
 238              		.cfi_def_cfa_offset 16
 239              		.cfi_offset 3, -16
 240              		.cfi_offset 4, -12
 241              		.cfi_offset 5, -8
 242              		.cfi_offset 14, -4
 243              		.loc 1 208 0
 244 0004 D368     		ldr	r3, [r2, #12]
 245 0006 8048     		ldr	r0, .L66+4
 246 0008 AA2B     		cmp	r3, #170
 247 000a 54D0     		beq	.L48
 248              	.L17:
 209:Src/stm32f1xx_it.c ****   {
 210:Src/stm32f1xx_it.c ****     start = true;
 211:Src/stm32f1xx_it.c ****     count = 0;
 212:Src/stm32f1xx_it.c ****   }
 213:Src/stm32f1xx_it.c ****   if((count >= 1)&&(count <= 3))
 249              		.loc 1 213 0
 250 000c 7F4C     		ldr	r4, .L66+8
 251 000e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 252 0010 5A1E     		subs	r2, r3, #1
 253 0012 022A     		cmp	r2, #2
 254 0014 5DD8     		bhi	.L20
 214:Src/stm32f1xx_it.c ****   {
 215:Src/stm32f1xx_it.c ****     buf[count-1] = SPI2->DR;
 255              		.loc 1 215 0
 256 0016 7B4A     		ldr	r2, .L66
 257 0018 7D4D     		ldr	r5, .L66+12
 258 001a D168     		ldr	r1, [r2, #12]
ARM GAS  /tmp/ccZ9uWVr.s 			page 9


 259 001c EA18     		adds	r2, r5, r3
 260 001e 02F8011C 		strb	r1, [r2, #-1]
 261              	.L21:
 216:Src/stm32f1xx_it.c ****   }
 217:Src/stm32f1xx_it.c ****   else if(count == 4)
 218:Src/stm32f1xx_it.c ****   {
 219:Src/stm32f1xx_it.c ****     SPI2->DR = 0;
 220:Src/stm32f1xx_it.c ****   }
 221:Src/stm32f1xx_it.c ****   else if(count == 5)
 222:Src/stm32f1xx_it.c ****   {
 223:Src/stm32f1xx_it.c ****     SPI2->DR = 0;
 224:Src/stm32f1xx_it.c ****   }
 225:Src/stm32f1xx_it.c ****   else
 226:Src/stm32f1xx_it.c ****   {
 227:Src/stm32f1xx_it.c ****     if(SPI2->DR == 0x55)
 228:Src/stm32f1xx_it.c ****     {
 229:Src/stm32f1xx_it.c ****       count = 0;
 230:Src/stm32f1xx_it.c ****       start = false;
 231:Src/stm32f1xx_it.c ****     }
 232:Src/stm32f1xx_it.c ****   }
 233:Src/stm32f1xx_it.c ****   if(start == true)
 262              		.loc 1 233 0
 263 0022 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 264 0024 012A     		cmp	r2, #1
 265 0026 51D0     		beq	.L19
 266              	.L24:
 234:Src/stm32f1xx_it.c ****     count ++;
 235:Src/stm32f1xx_it.c ****   /* USER CODE END SPI2_IRQn 0 */
 236:Src/stm32f1xx_it.c ****   HAL_SPI_IRQHandler(&hspi2);
 267              		.loc 1 236 0
 268 0028 7A48     		ldr	r0, .L66+16
 269 002a FFF7FEFF 		bl	HAL_SPI_IRQHandler
 270              	.LVL2:
 237:Src/stm32f1xx_it.c ****   /* USER CODE BEGIN SPI2_IRQn 1 */
 238:Src/stm32f1xx_it.c ****   if(buf[0] == 0x01){
 271              		.loc 1 238 0
 272 002e 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 273 0030 012B     		cmp	r3, #1
 274 0032 34D0     		beq	.L51
 239:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 240:Src/stm32f1xx_it.c ****     if(temp >= 0){
 241:Src/stm32f1xx_it.c ****       TIM1->CCR3 = temp;
 242:Src/stm32f1xx_it.c ****       TIM1->CCR4 = 0;
 243:Src/stm32f1xx_it.c ****     }else{
 244:Src/stm32f1xx_it.c ****       TIM1->CCR3 = 0;
 245:Src/stm32f1xx_it.c ****       TIM1->CCR4 = -temp;
 246:Src/stm32f1xx_it.c ****     }
 247:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x02){
 275              		.loc 1 247 0
 276 0034 022B     		cmp	r3, #2
 277 0036 26D0     		beq	.L52
 248:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 249:Src/stm32f1xx_it.c ****     if(temp >= 0){
 250:Src/stm32f1xx_it.c ****       TIM1->CCR1 = temp;
 251:Src/stm32f1xx_it.c ****       TIM1->CCR2 = 0;
 252:Src/stm32f1xx_it.c ****     }else{
 253:Src/stm32f1xx_it.c ****       TIM1->CCR1 = 0;
ARM GAS  /tmp/ccZ9uWVr.s 			page 10


 254:Src/stm32f1xx_it.c ****       TIM1->CCR2 = -temp;
 255:Src/stm32f1xx_it.c ****     }
 256:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x11){
 278              		.loc 1 256 0
 279 0038 112B     		cmp	r3, #17
 280 003a 67D0     		beq	.L53
 257:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 258:Src/stm32f1xx_it.c ****     TIM3->CCR4 = 1500 + temp;
 259:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x12){
 281              		.loc 1 259 0
 282 003c 122B     		cmp	r3, #18
 283 003e 73D0     		beq	.L54
 260:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 261:Src/stm32f1xx_it.c ****     TIM3->CCR3 = 1500 + temp;
 262:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x13){
 284              		.loc 1 262 0
 285 0040 132B     		cmp	r3, #19
 286 0042 59D0     		beq	.L55
 263:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 264:Src/stm32f1xx_it.c ****     TIM3->CCR2 = 1500 + temp;
 265:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x14){
 287              		.loc 1 265 0
 288 0044 142B     		cmp	r3, #20
 289 0046 00F08980 		beq	.L56
 266:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 267:Src/stm32f1xx_it.c ****     TIM3->CCR1 = 1500 + temp;
 268:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x15){
 290              		.loc 1 268 0
 291 004a 152B     		cmp	r3, #21
 292 004c 00F09080 		beq	.L57
 269:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 270:Src/stm32f1xx_it.c ****     TIM2->CCR4 = 1500 + temp;
 271:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x16){
 293              		.loc 1 271 0
 294 0050 162B     		cmp	r3, #22
 295 0052 78D0     		beq	.L58
 272:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 273:Src/stm32f1xx_it.c ****     TIM2->CCR3 = 1500 + temp;
 274:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x17){
 296              		.loc 1 274 0
 297 0054 172B     		cmp	r3, #23
 298 0056 00F09680 		beq	.L59
 275:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 276:Src/stm32f1xx_it.c ****     TIM2->CCR2 = 1500 + temp;
 277:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x18){
 299              		.loc 1 277 0
 300 005a 182B     		cmp	r3, #24
 301 005c 00F09E80 		beq	.L60
 278:Src/stm32f1xx_it.c ****     int16_t temp = (buf[1]<<8 | buf[2]);
 279:Src/stm32f1xx_it.c ****     TIM2->CCR1 = 1500 + temp;
 280:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x21){
 302              		.loc 1 280 0
 303 0060 212B     		cmp	r3, #33
 304 0062 00F0A680 		beq	.L61
 281:Src/stm32f1xx_it.c ****     if(count == 4){
 282:Src/stm32f1xx_it.c ****       SPI2->DR = ((gray_data_final&0xff00)>>8);
 283:Src/stm32f1xx_it.c ****     }
ARM GAS  /tmp/ccZ9uWVr.s 			page 11


 284:Src/stm32f1xx_it.c ****     else if(count == 5){
 285:Src/stm32f1xx_it.c ****       SPI2->DR = (gray_data_final&0x00ff);
 286:Src/stm32f1xx_it.c ****     }
 287:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x22){
 305              		.loc 1 287 0
 306 0066 222B     		cmp	r3, #34
 307 0068 00F0AE80 		beq	.L62
 288:Src/stm32f1xx_it.c ****     if(count == 4){
 289:Src/stm32f1xx_it.c ****       SPI2->DR = ((gray_data_two_final&0xff00)>>8);
 290:Src/stm32f1xx_it.c ****     }
 291:Src/stm32f1xx_it.c ****     else if(count == 5){
 292:Src/stm32f1xx_it.c ****       SPI2->DR = (gray_data_two_final&0x00ff);
 293:Src/stm32f1xx_it.c ****     }
 294:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x31){
 308              		.loc 1 294 0
 309 006c 312B     		cmp	r3, #49
 310 006e 09D1     		bne	.L16
 295:Src/stm32f1xx_it.c ****     if(count == 4){
 311              		.loc 1 295 0
 312 0070 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 313 0072 042B     		cmp	r3, #4
 314 0074 00F0BF80 		beq	.L63
 296:Src/stm32f1xx_it.c ****       SPI2->DR = ((other_data_final&0xff00)>>8);
 297:Src/stm32f1xx_it.c ****     }
 298:Src/stm32f1xx_it.c ****     else if(count == 5){
 315              		.loc 1 298 0
 316 0078 052B     		cmp	r3, #5
 317 007a 03D1     		bne	.L16
 299:Src/stm32f1xx_it.c ****       SPI2->DR = (other_data_final&0x00ff);
 318              		.loc 1 299 0
 319 007c 664A     		ldr	r2, .L66+20
 320 007e 614B     		ldr	r3, .L66
 321 0080 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 322 0082 DA60     		str	r2, [r3, #12]
 323              	.L16:
 300:Src/stm32f1xx_it.c ****     }
 301:Src/stm32f1xx_it.c ****   }
 302:Src/stm32f1xx_it.c ****   
 303:Src/stm32f1xx_it.c ****   /* USER CODE END SPI2_IRQn 1 */
 304:Src/stm32f1xx_it.c **** }
 324              		.loc 1 304 0
 325 0084 38BD     		pop	{r3, r4, r5, pc}
 326              	.L52:
 327              	.LBB2:
 248:Src/stm32f1xx_it.c ****     if(temp >= 0){
 328              		.loc 1 248 0
 329 0086 6A78     		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 330 0088 AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 251:Src/stm32f1xx_it.c ****     }else{
 331              		.loc 1 251 0
 332 008a 0021     		movs	r1, #0
 248:Src/stm32f1xx_it.c ****     if(temp >= 0){
 333              		.loc 1 248 0
 334 008c 43EA0223 		orr	r3, r3, r2, lsl #8
 335 0090 1BB2     		sxth	r3, r3
 336              	.LVL3:
 249:Src/stm32f1xx_it.c ****       TIM1->CCR1 = temp;
ARM GAS  /tmp/ccZ9uWVr.s 			page 12


 337              		.loc 1 249 0
 338 0092 002B     		cmp	r3, #0
 250:Src/stm32f1xx_it.c ****       TIM1->CCR2 = 0;
 339              		.loc 1 250 0
 340 0094 614A     		ldr	r2, .L66+24
 249:Src/stm32f1xx_it.c ****       TIM1->CCR1 = temp;
 341              		.loc 1 249 0
 342 0096 2BDB     		blt	.L29
 250:Src/stm32f1xx_it.c ****       TIM1->CCR2 = 0;
 343              		.loc 1 250 0
 344 0098 5363     		str	r3, [r2, #52]
 251:Src/stm32f1xx_it.c ****     }else{
 345              		.loc 1 251 0
 346 009a 9163     		str	r1, [r2, #56]
 347              	.LBE2:
 348              		.loc 1 304 0
 349 009c 38BD     		pop	{r3, r4, r5, pc}
 350              	.LVL4:
 351              	.L51:
 352              	.LBB3:
 239:Src/stm32f1xx_it.c ****     if(temp >= 0){
 353              		.loc 1 239 0
 354 009e 6A78     		ldrb	r2, [r5, #1]	@ zero_extendqisi2
 355 00a0 AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 242:Src/stm32f1xx_it.c ****     }else{
 356              		.loc 1 242 0
 357 00a2 0021     		movs	r1, #0
 239:Src/stm32f1xx_it.c ****     if(temp >= 0){
 358              		.loc 1 239 0
 359 00a4 43EA0223 		orr	r3, r3, r2, lsl #8
 360 00a8 1BB2     		sxth	r3, r3
 361              	.LVL5:
 240:Src/stm32f1xx_it.c ****       TIM1->CCR3 = temp;
 362              		.loc 1 240 0
 363 00aa 002B     		cmp	r3, #0
 241:Src/stm32f1xx_it.c ****       TIM1->CCR4 = 0;
 364              		.loc 1 241 0
 365 00ac 5B4A     		ldr	r2, .L66+24
 240:Src/stm32f1xx_it.c ****       TIM1->CCR3 = temp;
 366              		.loc 1 240 0
 367 00ae 37DB     		blt	.L26
 241:Src/stm32f1xx_it.c ****       TIM1->CCR4 = 0;
 368              		.loc 1 241 0
 369 00b0 D363     		str	r3, [r2, #60]
 242:Src/stm32f1xx_it.c ****     }else{
 370              		.loc 1 242 0
 371 00b2 1164     		str	r1, [r2, #64]
 372              	.LBE3:
 373              		.loc 1 304 0
 374 00b4 38BD     		pop	{r3, r4, r5, pc}
 375              	.LVL6:
 376              	.L48:
 208:Src/stm32f1xx_it.c ****   {
 377              		.loc 1 208 0 discriminator 1
 378 00b6 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 379 00b8 002B     		cmp	r3, #0
 380 00ba A7D1     		bne	.L17
ARM GAS  /tmp/ccZ9uWVr.s 			page 13


 210:Src/stm32f1xx_it.c ****     count = 0;
 381              		.loc 1 210 0
 382 00bc 0121     		movs	r1, #1
 211:Src/stm32f1xx_it.c ****   }
 383              		.loc 1 211 0
 384 00be 534C     		ldr	r4, .L66+8
 210:Src/stm32f1xx_it.c ****     count = 0;
 385              		.loc 1 210 0
 386 00c0 0170     		strb	r1, [r0]
 211:Src/stm32f1xx_it.c ****   }
 387              		.loc 1 211 0
 388 00c2 2370     		strb	r3, [r4]
 227:Src/stm32f1xx_it.c ****     {
 389              		.loc 1 227 0
 390 00c4 D268     		ldr	r2, [r2, #12]
 391 00c6 552A     		cmp	r2, #85
 392 00c8 38D0     		beq	.L18
 393 00ca 514D     		ldr	r5, .L66+12
 394              	.L19:
 234:Src/stm32f1xx_it.c ****   /* USER CODE END SPI2_IRQn 0 */
 395              		.loc 1 234 0
 396 00cc 0133     		adds	r3, r3, #1
 397 00ce 2370     		strb	r3, [r4]
 398 00d0 AAE7     		b	.L24
 399              	.L20:
 217:Src/stm32f1xx_it.c ****   {
 400              		.loc 1 217 0
 401 00d2 042B     		cmp	r3, #4
 402 00d4 04D1     		bne	.L22
 403              	.L50:
 223:Src/stm32f1xx_it.c ****   }
 404              		.loc 1 223 0
 405 00d6 0021     		movs	r1, #0
 406 00d8 4A4A     		ldr	r2, .L66
 407 00da 4D4D     		ldr	r5, .L66+12
 408 00dc D160     		str	r1, [r2, #12]
 409 00de A0E7     		b	.L21
 410              	.L22:
 221:Src/stm32f1xx_it.c ****   {
 411              		.loc 1 221 0
 412 00e0 052B     		cmp	r3, #5
 413 00e2 F8D0     		beq	.L50
 227:Src/stm32f1xx_it.c ****     {
 414              		.loc 1 227 0
 415 00e4 474A     		ldr	r2, .L66
 416 00e6 D268     		ldr	r2, [r2, #12]
 417 00e8 552A     		cmp	r2, #85
 418 00ea 27D0     		beq	.L18
 419 00ec 484D     		ldr	r5, .L66+12
 420 00ee 98E7     		b	.L21
 421              	.LVL7:
 422              	.L29:
 423              	.LBB4:
 254:Src/stm32f1xx_it.c ****     }
 424              		.loc 1 254 0
 425 00f0 5B42     		negs	r3, r3
 426              	.LVL8:
ARM GAS  /tmp/ccZ9uWVr.s 			page 14


 253:Src/stm32f1xx_it.c ****       TIM1->CCR2 = -temp;
 427              		.loc 1 253 0
 428 00f2 5163     		str	r1, [r2, #52]
 254:Src/stm32f1xx_it.c ****     }
 429              		.loc 1 254 0
 430 00f4 9363     		str	r3, [r2, #56]
 431              	.LBE4:
 432              		.loc 1 304 0
 433 00f6 38BD     		pop	{r3, r4, r5, pc}
 434              	.LVL9:
 435              	.L55:
 436              	.LBB5:
 263:Src/stm32f1xx_it.c ****     TIM3->CCR2 = 1500 + temp;
 437              		.loc 1 263 0
 438 00f8 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 439 00fa AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 264:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x14){
 440              		.loc 1 264 0
 441 00fc 484A     		ldr	r2, .L66+28
 263:Src/stm32f1xx_it.c ****     TIM3->CCR2 = 1500 + temp;
 442              		.loc 1 263 0
 443 00fe 43EA0123 		orr	r3, r3, r1, lsl #8
 264:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x14){
 444              		.loc 1 264 0
 445 0102 1BB2     		sxth	r3, r3
 446 0104 03F2DC53 		addw	r3, r3, #1500
 447 0108 9363     		str	r3, [r2, #56]
 448              	.LVL10:
 449              	.LBE5:
 450              		.loc 1 304 0
 451 010a 38BD     		pop	{r3, r4, r5, pc}
 452              	.L53:
 453              	.LVL11:
 454              	.LBB6:
 257:Src/stm32f1xx_it.c ****     TIM3->CCR4 = 1500 + temp;
 455              		.loc 1 257 0
 456 010c 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 457 010e AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 258:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x12){
 458              		.loc 1 258 0
 459 0110 434A     		ldr	r2, .L66+28
 257:Src/stm32f1xx_it.c ****     TIM3->CCR4 = 1500 + temp;
 460              		.loc 1 257 0
 461 0112 43EA0123 		orr	r3, r3, r1, lsl #8
 258:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x12){
 462              		.loc 1 258 0
 463 0116 1BB2     		sxth	r3, r3
 464 0118 03F2DC53 		addw	r3, r3, #1500
 465 011c 1364     		str	r3, [r2, #64]
 466              	.LVL12:
 467              	.LBE6:
 468              		.loc 1 304 0
 469 011e 38BD     		pop	{r3, r4, r5, pc}
 470              	.LVL13:
 471              	.L26:
 472              	.LBB7:
 245:Src/stm32f1xx_it.c ****     }
ARM GAS  /tmp/ccZ9uWVr.s 			page 15


 473              		.loc 1 245 0
 474 0120 5B42     		negs	r3, r3
 475              	.LVL14:
 244:Src/stm32f1xx_it.c ****       TIM1->CCR4 = -temp;
 476              		.loc 1 244 0
 477 0122 D163     		str	r1, [r2, #60]
 245:Src/stm32f1xx_it.c ****     }
 478              		.loc 1 245 0
 479 0124 1364     		str	r3, [r2, #64]
 480              	.LBE7:
 481              		.loc 1 304 0
 482 0126 38BD     		pop	{r3, r4, r5, pc}
 483              	.LVL15:
 484              	.L54:
 485              	.LBB8:
 260:Src/stm32f1xx_it.c ****     TIM3->CCR3 = 1500 + temp;
 486              		.loc 1 260 0
 487 0128 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 488 012a AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 261:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x13){
 489              		.loc 1 261 0
 490 012c 3C4A     		ldr	r2, .L66+28
 260:Src/stm32f1xx_it.c ****     TIM3->CCR3 = 1500 + temp;
 491              		.loc 1 260 0
 492 012e 43EA0123 		orr	r3, r3, r1, lsl #8
 261:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x13){
 493              		.loc 1 261 0
 494 0132 1BB2     		sxth	r3, r3
 495 0134 03F2DC53 		addw	r3, r3, #1500
 496 0138 D363     		str	r3, [r2, #60]
 497              	.LVL16:
 498              	.LBE8:
 499              		.loc 1 304 0
 500 013a 38BD     		pop	{r3, r4, r5, pc}
 501              	.L18:
 229:Src/stm32f1xx_it.c ****       start = false;
 502              		.loc 1 229 0
 503 013c 0023     		movs	r3, #0
 504 013e 344D     		ldr	r5, .L66+12
 505 0140 2370     		strb	r3, [r4]
 230:Src/stm32f1xx_it.c ****     }
 506              		.loc 1 230 0
 507 0142 0370     		strb	r3, [r0]
 508 0144 70E7     		b	.L24
 509              	.L58:
 510              	.LVL17:
 511              	.LBB9:
 273:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x17){
 512              		.loc 1 273 0
 513 0146 4FF08042 		mov	r2, #1073741824
 272:Src/stm32f1xx_it.c ****     TIM2->CCR3 = 1500 + temp;
 514              		.loc 1 272 0
 515 014a 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 516 014c AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 517 014e 43EA0123 		orr	r3, r3, r1, lsl #8
 273:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x17){
 518              		.loc 1 273 0
ARM GAS  /tmp/ccZ9uWVr.s 			page 16


 519 0152 1BB2     		sxth	r3, r3
 520 0154 03F2DC53 		addw	r3, r3, #1500
 521 0158 D363     		str	r3, [r2, #60]
 522              	.LVL18:
 523              	.LBE9:
 524              		.loc 1 304 0
 525 015a 38BD     		pop	{r3, r4, r5, pc}
 526              	.L56:
 527              	.LVL19:
 528              	.LBB10:
 266:Src/stm32f1xx_it.c ****     TIM3->CCR1 = 1500 + temp;
 529              		.loc 1 266 0
 530 015c 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 531 015e AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 267:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x15){
 532              		.loc 1 267 0
 533 0160 2F4A     		ldr	r2, .L66+28
 266:Src/stm32f1xx_it.c ****     TIM3->CCR1 = 1500 + temp;
 534              		.loc 1 266 0
 535 0162 43EA0123 		orr	r3, r3, r1, lsl #8
 267:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x15){
 536              		.loc 1 267 0
 537 0166 1BB2     		sxth	r3, r3
 538 0168 03F2DC53 		addw	r3, r3, #1500
 539 016c 5363     		str	r3, [r2, #52]
 540              	.LVL20:
 541              	.LBE10:
 542              		.loc 1 304 0
 543 016e 38BD     		pop	{r3, r4, r5, pc}
 544              	.L57:
 545              	.LVL21:
 546              	.LBB11:
 270:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x16){
 547              		.loc 1 270 0
 548 0170 4FF08042 		mov	r2, #1073741824
 269:Src/stm32f1xx_it.c ****     TIM2->CCR4 = 1500 + temp;
 549              		.loc 1 269 0
 550 0174 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 551 0176 AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 552 0178 43EA0123 		orr	r3, r3, r1, lsl #8
 270:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x16){
 553              		.loc 1 270 0
 554 017c 1BB2     		sxth	r3, r3
 555 017e 03F2DC53 		addw	r3, r3, #1500
 556 0182 1364     		str	r3, [r2, #64]
 557              	.LVL22:
 558              	.LBE11:
 559              		.loc 1 304 0
 560 0184 38BD     		pop	{r3, r4, r5, pc}
 561              	.L59:
 562              	.LVL23:
 563              	.LBB12:
 276:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x18){
 564              		.loc 1 276 0
 565 0186 4FF08042 		mov	r2, #1073741824
 275:Src/stm32f1xx_it.c ****     TIM2->CCR2 = 1500 + temp;
 566              		.loc 1 275 0
ARM GAS  /tmp/ccZ9uWVr.s 			page 17


 567 018a 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 568 018c AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 569 018e 43EA0123 		orr	r3, r3, r1, lsl #8
 276:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x18){
 570              		.loc 1 276 0
 571 0192 1BB2     		sxth	r3, r3
 572 0194 03F2DC53 		addw	r3, r3, #1500
 573 0198 9363     		str	r3, [r2, #56]
 574              	.LVL24:
 575              	.LBE12:
 576              		.loc 1 304 0
 577 019a 38BD     		pop	{r3, r4, r5, pc}
 578              	.L60:
 579              	.LVL25:
 580              	.LBB13:
 279:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x21){
 581              		.loc 1 279 0
 582 019c 4FF08042 		mov	r2, #1073741824
 278:Src/stm32f1xx_it.c ****     TIM2->CCR1 = 1500 + temp;
 583              		.loc 1 278 0
 584 01a0 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 585 01a2 AB78     		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 586 01a4 43EA0123 		orr	r3, r3, r1, lsl #8
 279:Src/stm32f1xx_it.c ****   }else if(buf[0] == 0x21){
 587              		.loc 1 279 0
 588 01a8 1BB2     		sxth	r3, r3
 589 01aa 03F2DC53 		addw	r3, r3, #1500
 590 01ae 5363     		str	r3, [r2, #52]
 591              	.LVL26:
 592              	.LBE13:
 593              		.loc 1 304 0
 594 01b0 38BD     		pop	{r3, r4, r5, pc}
 595              	.L61:
 281:Src/stm32f1xx_it.c ****       SPI2->DR = ((gray_data_final&0xff00)>>8);
 596              		.loc 1 281 0
 597 01b2 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 598 01b4 042B     		cmp	r3, #4
 599 01b6 12D0     		beq	.L64
 284:Src/stm32f1xx_it.c ****       SPI2->DR = (gray_data_final&0x00ff);
 600              		.loc 1 284 0
 601 01b8 052B     		cmp	r3, #5
 602 01ba 7FF463AF 		bne	.L16
 285:Src/stm32f1xx_it.c ****     }
 603              		.loc 1 285 0
 604 01be 194A     		ldr	r2, .L66+32
 605 01c0 104B     		ldr	r3, .L66
 606 01c2 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 607 01c4 DA60     		str	r2, [r3, #12]
 608              		.loc 1 304 0
 609 01c6 38BD     		pop	{r3, r4, r5, pc}
 610              	.L62:
 288:Src/stm32f1xx_it.c ****       SPI2->DR = ((gray_data_two_final&0xff00)>>8);
 611              		.loc 1 288 0
 612 01c8 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 613 01ca 042B     		cmp	r3, #4
 614 01cc 0DD0     		beq	.L65
 291:Src/stm32f1xx_it.c ****       SPI2->DR = (gray_data_two_final&0x00ff);
ARM GAS  /tmp/ccZ9uWVr.s 			page 18


 615              		.loc 1 291 0
 616 01ce 052B     		cmp	r3, #5
 617 01d0 7FF458AF 		bne	.L16
 292:Src/stm32f1xx_it.c ****     }
 618              		.loc 1 292 0
 619 01d4 144A     		ldr	r2, .L66+36
 620 01d6 0B4B     		ldr	r3, .L66
 621 01d8 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 622 01da DA60     		str	r2, [r3, #12]
 623              		.loc 1 304 0
 624 01dc 38BD     		pop	{r3, r4, r5, pc}
 625              	.L64:
 282:Src/stm32f1xx_it.c ****     }
 626              		.loc 1 282 0
 627 01de 114B     		ldr	r3, .L66+32
 628 01e0 084A     		ldr	r2, .L66
 629 01e2 1B88     		ldrh	r3, [r3]
 630 01e4 1B0A     		lsrs	r3, r3, #8
 631 01e6 D360     		str	r3, [r2, #12]
 632              		.loc 1 304 0
 633 01e8 38BD     		pop	{r3, r4, r5, pc}
 634              	.L65:
 289:Src/stm32f1xx_it.c ****     }
 635              		.loc 1 289 0
 636 01ea 0F4B     		ldr	r3, .L66+36
 637 01ec 054A     		ldr	r2, .L66
 638 01ee 1B88     		ldrh	r3, [r3]
 639 01f0 1B0A     		lsrs	r3, r3, #8
 640 01f2 D360     		str	r3, [r2, #12]
 641              		.loc 1 304 0
 642 01f4 38BD     		pop	{r3, r4, r5, pc}
 643              	.L63:
 296:Src/stm32f1xx_it.c ****     }
 644              		.loc 1 296 0
 645 01f6 084B     		ldr	r3, .L66+20
 646 01f8 024A     		ldr	r2, .L66
 647 01fa 1B88     		ldrh	r3, [r3]
 648 01fc 1B0A     		lsrs	r3, r3, #8
 649 01fe D360     		str	r3, [r2, #12]
 650              		.loc 1 304 0
 651 0200 38BD     		pop	{r3, r4, r5, pc}
 652              	.L67:
 653 0202 00BF     		.align	2
 654              	.L66:
 655 0204 00380040 		.word	1073756160
 656 0208 00000000 		.word	.LANCHOR0
 657 020c 00000000 		.word	.LANCHOR1
 658 0210 00000000 		.word	.LANCHOR2
 659 0214 00000000 		.word	hspi2
 660 0218 00000000 		.word	other_data_final
 661 021c 002C0140 		.word	1073818624
 662 0220 00040040 		.word	1073742848
 663 0224 00000000 		.word	gray_data_final
 664 0228 00000000 		.word	gray_data_two_final
 665              		.cfi_endproc
 666              	.LFE75:
 668              		.section	.bss.buf.7222,"aw",%nobits
ARM GAS  /tmp/ccZ9uWVr.s 			page 19


 669              		.align	2
 670              		.set	.LANCHOR2,. + 0
 673              	buf.7222:
 674 0000 00000000 		.space	5
 674      00
 675              		.section	.bss.count.7223,"aw",%nobits
 676              		.set	.LANCHOR1,. + 0
 679              	count.7223:
 680 0000 00       		.space	1
 681              		.section	.bss.start.7221,"aw",%nobits
 682              		.set	.LANCHOR0,. + 0
 685              	start.7221:
 686 0000 00       		.space	1
 687              		.text
 688              	.Letext0:
 689              		.file 2 "Inc/main.h"
 690              		.file 3 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/machine/_default_type
 691              		.file 4 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/_stdint.h"
 692              		.file 5 "Drivers/CMSIS/Include/core_cm3.h"
 693              		.file 6 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 694              		.file 7 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 695              		.file 8 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/lock.h"
 696              		.file 9 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/_types.h"
 697              		.file 10 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/lib/gcc/arm-none-eabi/7.3.1/include/stddef
 698              		.file 11 "/usr/local/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/reent.h"
 699              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 700              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 701              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_spi.h"
 702              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 703              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_cortex.h"
ARM GAS  /tmp/ccZ9uWVr.s 			page 20


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f1xx_it.c
     /tmp/ccZ9uWVr.s:16     .text.NMI_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:24     .text.NMI_Handler:0000000000000000 NMI_Handler
     /tmp/ccZ9uWVr.s:38     .text.HardFault_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:46     .text.HardFault_Handler:0000000000000000 HardFault_Handler
     /tmp/ccZ9uWVr.s:60     .text.MemManage_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:68     .text.MemManage_Handler:0000000000000000 MemManage_Handler
     /tmp/ccZ9uWVr.s:82     .text.BusFault_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:90     .text.BusFault_Handler:0000000000000000 BusFault_Handler
     /tmp/ccZ9uWVr.s:104    .text.UsageFault_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:112    .text.UsageFault_Handler:0000000000000000 UsageFault_Handler
     /tmp/ccZ9uWVr.s:126    .text.SVC_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:134    .text.SVC_Handler:0000000000000000 SVC_Handler
     /tmp/ccZ9uWVr.s:145    .text.DebugMon_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:153    .text.DebugMon_Handler:0000000000000000 DebugMon_Handler
     /tmp/ccZ9uWVr.s:164    .text.PendSV_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:172    .text.PendSV_Handler:0000000000000000 PendSV_Handler
     /tmp/ccZ9uWVr.s:183    .text.SysTick_Handler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:191    .text.SysTick_Handler:0000000000000000 SysTick_Handler
     /tmp/ccZ9uWVr.s:219    .text.SPI2_IRQHandler:0000000000000000 $t
     /tmp/ccZ9uWVr.s:227    .text.SPI2_IRQHandler:0000000000000000 SPI2_IRQHandler
     /tmp/ccZ9uWVr.s:655    .text.SPI2_IRQHandler:0000000000000204 $d
     /tmp/ccZ9uWVr.s:669    .bss.buf.7222:0000000000000000 $d
     /tmp/ccZ9uWVr.s:673    .bss.buf.7222:0000000000000000 buf.7222
     /tmp/ccZ9uWVr.s:679    .bss.count.7223:0000000000000000 count.7223
     /tmp/ccZ9uWVr.s:680    .bss.count.7223:0000000000000000 $d
     /tmp/ccZ9uWVr.s:685    .bss.start.7221:0000000000000000 start.7221
     /tmp/ccZ9uWVr.s:686    .bss.start.7221:0000000000000000 $d

UNDEFINED SYMBOLS
HAL_IncTick
HAL_SYSTICK_IRQHandler
HAL_SPI_IRQHandler
hspi2
other_data_final
gray_data_final
gray_data_two_final
